<!DOCTYPE html>
<html lang="hr" dir="ltr">
<head>
<meta charset="UTF-8" />
<title>Spring Security framework - SIS Wiki</title>
<meta name="generator" content="MediaWiki 1.17.0" />
<link rel="shortcut icon" href="http://security.foi.hr/favicon.ico" />
<link rel="search" type="application/opensearchdescription+xml" href="../opensearch_desc.php" title="SIS Wiki (hr)" />
<link rel="EditURI" type="application/rsd+xml" href="../api.php%3Faction=rsd" />
<link title="Creative Commons" type="application/rdf+xml" href="http://security.foi.hr/wiki/index.php?title=Spring_Security_framework&amp;action=creativecommons" rel="meta" />
<link rel="copyright" href="http://creativecommons.org/licenses/by-sa/3.0/" />
<link rel="alternate" type="application/atom+xml" title="SIS Wiki Atom izvor" href="../index.php%3Ftitle=Posebno:Nedavne_promjene&amp;feed=atom" />
<link rel="stylesheet" href="../load.php%3Fdebug=false&amp;lang=hr&amp;modules=mediawiki.legacy.commonPrint%252Cshared%257Cskins.vector&amp;only=styles&amp;skin=vector&amp;*.css" />
<meta name="ResourceLoaderDynamicStyles" content="" />
<!--[if lt IE 7]><style type="text/css">body{behavior:url("/wiki/skins/vector/csshover.min.htc")}</style><![endif]--></head>
<body class="mediawiki ltr ns-0 ns-subject page-Spring_Security_framework skin-vector">
		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<!-- content -->
		<div id="content">
			<a id="top"></a>
			<div id="mw-js-message" style="display:none;"></div>
						<!-- firstHeading -->
			<h1 id="firstHeading" class="firstHeading">Spring Security framework</h1>
			<!-- /firstHeading -->
			<!-- bodyContent -->
			<div id="bodyContent">
				<!-- tagline -->
				<div id="siteSub">Izvor: SIS Wiki</div>
				<!-- /tagline -->
				<!-- subtitle -->
				<div id="contentSub"></div>
				<!-- /subtitle -->
																<!-- jumpto -->
				<div id="jump-to-nav">
					Skoči na: <a href="Spring_Security_framework.html#mw-head">orijentacija</a>,
					<a href="Spring_Security_framework.html#p-search">traži</a>
				</div>
				<!-- /jumpto -->
								<!-- bodytext -->
				<p>Temu rezervirao:
Alen Martinčević
</p><p><br />
</p>
<table id="toc" class="toc"><tr><td><div id="toctitle"><h2>Sadržaj</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="Spring_Security_framework.html#Ukratko_o_Spring_Security_framework-u"><span class="tocnumber">1</span> <span class="toctext">Ukratko o Spring Security framework-u</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="Spring_Security_framework.html#Kreiranje_Spring_projekta"><span class="tocnumber">2</span> <span class="toctext">Kreiranje Spring projekta</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="Spring_Security_framework.html#Rad_sa_Spring_Security_okvirom"><span class="tocnumber">3</span> <span class="toctext">Rad sa Spring Security okvirom</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="Spring_Security_framework.html#Baza_podataka"><span class="tocnumber">4</span> <span class="toctext">Baza podataka</span></a>
<ul>
<li class="toclevel-2"><a href="Spring_Security_framework.html#User"><span class="tocnumber">4.1</span> <span class="toctext">User</span></a></li>
<li class="toclevel-2"><a href="Spring_Security_framework.html#Role"><span class="tocnumber">4.2</span> <span class="toctext">Role</span></a></li>
<li class="toclevel-2"><a href="Spring_Security_framework.html#VerificaitonToken"><span class="tocnumber">4.3</span> <span class="toctext">VerificaitonToken</span></a></li>
<li class="toclevel-2"><a href="Spring_Security_framework.html#PasswordResetToken"><span class="tocnumber">4.4</span> <span class="toctext">PasswordResetToken</span></a></li>
<li class="toclevel-2"><a href="Spring_Security_framework.html#UserRepository"><span class="tocnumber">4.5</span> <span class="toctext">UserRepository</span></a></li>
<li class="toclevel-2"><a href="Spring_Security_framework.html#RoleRepository"><span class="tocnumber">4.6</span> <span class="toctext">RoleRepository</span></a></li>
<li class="toclevel-2"><a href="Spring_Security_framework.html#VerificationTokenRepository"><span class="tocnumber">4.7</span> <span class="toctext">VerificationTokenRepository</span></a></li>
<li class="toclevel-2"><a href="Spring_Security_framework.html#PasswordResetTokenRepository"><span class="tocnumber">4.8</span> <span class="toctext">PasswordResetTokenRepository</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-5"><a href="Spring_Security_framework.html#Za.C5.A1tita_aplikacije"><span class="tocnumber">5</span> <span class="toctext">Zaštita aplikacije</span></a>
<ul>
<li class="toclevel-2"><a href="Spring_Security_framework.html#Postavljanje_sigurnosne_konfiguracije"><span class="tocnumber">5.1</span> <span class="toctext">Postavljanje sigurnosne konfiguracije</span></a></li>
<li class="toclevel-2"><a href="Spring_Security_framework.html#CustomAuthenticationProvider"><span class="tocnumber">5.2</span> <span class="toctext">CustomAuthenticationProvider</span></a></li>
<li class="toclevel-2"><a href="Spring_Security_framework.html#HttpSecurity"><span class="tocnumber">5.3</span> <span class="toctext">HttpSecurity</span></a>
<ul>
<li class="toclevel-3"><a href="Spring_Security_framework.html#CSRF_za.C5.A1tita"><span class="tocnumber">5.3.1</span> <span class="toctext">CSRF zaštita</span></a></li>
<li class="toclevel-3"><a href="Spring_Security_framework.html#HTTPS"><span class="tocnumber">5.3.2</span> <span class="toctext">HTTPS</span></a></li>
<li class="toclevel-3"><a href="Spring_Security_framework.html#Rad_sa_sesijama"><span class="tocnumber">5.3.3</span> <span class="toctext">Rad sa sesijama</span></a></li>
<li class="toclevel-3"><a href="Spring_Security_framework.html#Autorizacija_zahtjeva"><span class="tocnumber">5.3.4</span> <span class="toctext">Autorizacija zahtjeva</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="Spring_Security_framework.html#UserDetailService"><span class="tocnumber">5.4</span> <span class="toctext">UserDetailService</span></a></li>
<li class="toclevel-2"><a href="Spring_Security_framework.html#Brute_force_napad"><span class="tocnumber">5.5</span> <span class="toctext">Brute force napad</span></a></li>
<li class="toclevel-2"><a href="Spring_Security_framework.html#Provjera_ja.C4.8Dine_lozinke_.28backend.29"><span class="tocnumber">5.6</span> <span class="toctext">Provjera jačine lozinke (backend)</span></a></li>
<li class="toclevel-2"><a href="Spring_Security_framework.html#Encoder_.28kriptiranje_lozinke.29"><span class="tocnumber">5.7</span> <span class="toctext">Encoder (kriptiranje lozinke)</span></a></li>
<li class="toclevel-2"><a href="Spring_Security_framework.html#Dvo_faktorska_autorizacija"><span class="tocnumber">5.8</span> <span class="toctext">Dvo faktorska autorizacija</span></a></li>
<li class="toclevel-2"><a href="Spring_Security_framework.html#Validacija_tokena_za_resetiranje_lozinke"><span class="tocnumber">5.9</span> <span class="toctext">Validacija tokena za resetiranje lozinke</span></a></li>
<li class="toclevel-2"><a href="Spring_Security_framework.html#Validacija_tokena_za_verifikaciju"><span class="tocnumber">5.10</span> <span class="toctext">Validacija tokena za verifikaciju</span></a></li>
<li class="toclevel-2"><a href="Spring_Security_framework.html#Recaptcha"><span class="tocnumber">5.11</span> <span class="toctext">Recaptcha</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-6"><a href="Spring_Security_framework.html#Aplikacija"><span class="tocnumber">6</span> <span class="toctext">Aplikacija</span></a></li>
</ul>
</td></tr></table>
<h2> <span class="mw-headline" id="Ukratko_o_Spring_Security_framework-u"> Ukratko o Spring Security framework-u </span></h2>
<p>Spring security je Java/Java EE okvir koji omogućuje korištenje sigurnosnih mehanizama. Dva glavna područja na koja se Spring Security bazira jesu autentifikacija te autorizacijski mehanizam. Pod autentifikacijom smatramo postupak provjeravanja da li je netko onaj za koga se predstavlja da je (tu se prvenstveno pod tim nekim smatra uređaj ili neki drugi sustav koji može izvoditi neke akcije u vašoj aplikaciji). S druge strane autorizacija predstavlja mehanizam provjeravanja da li autentificirani korisnik ima prava tj. da li mu je dozvoljeno izvršavanje određenih radnji unutar aplikacije i ako jest kojih to sve točno radnji. 
</p><p><strong>Neka od značajki koje nudi Spring Security:</strong><br />
- Sveobuhvatna i proširiva podrška za autentifikaciju i autorizaciju<br />
- Zaštitu protiv napada kao što su session fixation, clickjacking, XSS, CSRF (Cross site request forgery), brute force napadi i slično<br />
- Integracija servlet API-a<br />
- Opcionalna integracija s Spring Web MVC<br />
- i još mnogo toga<br />
</p><p><br />
Na autentifikacijskoj razini, Spring Securit podržava široki raspon auntentikacijskih modula. Većina tih modula  su pruženi od strane trećih strana ili su razvijeni od strane grupa koji se specijalizirano bave razvojem interneta i protokola kao što je IETE (Internet Engineering Task Force). Također, Spring Security pruža i set svojih vlastitih autentikacijskih značajki.
</p><p><strong>Neki od podržanih autentifikacijskih modula jesu:</strong><br />
- HTTP BASIC autentikacijska zaglavlja<br />
- HTTP Digest autentikacijska zaglavlja<br />
- HTTP X.509 za razmjenu klijentskih certifikata<br />
- LDAP (u svrhe multi-platforme autentikacije)<br />
- Autentikacija bazirana na obrascu<br />
- OpenID autentikacija<br />
- Kerberos<br />
- i još mnogi drugi<br />
</p><p><br />
</p>
<h2> <span class="mw-headline" id="Kreiranje_Spring_projekta"> Kreiranje Spring projekta </span></h2>
<p>Kako bismo mogli koristiti naveden okvir za sigurnost (Spring Security) potrebno je kreirati Spring projekt. Postoje dva načina veoma laka načina. Jedan je da Spring projekt kreiramo pomoću IDEA koji podržava rad sa Springom kao što je primjerice IntelliJ. Drugi način je preko stranice Spring Initializr (<a href="https://start.spring.io" class="external free" rel="nofollow">https://start.spring.io</a>) koja nam nudi automatsko generiranje datoteka potrebnih za pokretanje i rad Spring aplikacije ukomponiranih u datoteku projekta. Osim standardnih datoteka potrebnih za rad, moguće je odmah i dodati dodatne module tj. zavisnosti (eng. Dependencies). Primjerice, ako želimo raditi Web aplikaciju, potrebno je dodati modul Web. Isto tako ako želimo koristiti značajke Spring Security-a potrebno je dodati modul Security. U ovom projektu korištena su oba modula, uz dodatak JPA modula koji nam omogućuje korištenje ORM (Object-relation mapping) okvira, konkretno Hibernate okvira koji nam uvelike olakšava rad s bazom.
</p><p><a href="http://security.foi.hr/wiki/index.php/Datoteka:Spring_Initializr.png" class="image"><img alt="Spring Initializr.png" src="../images/thumb/6/6c/Spring_Initializr.png/1000px-Spring_Initializr.png" width="1000" height="530" /></a>
</p><p><br />
Naravno dodatne module je moguće dodati i ručno. Pa tako ako želite dodati Spring Security potrebno je u datoteku pom.xml dodati sljedeći isječak koda u sekciju <strong>&lt;dependencies&gt;&lt;/dependencies&gt;</strong>.
</p>
<pre>
&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
	&lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
&lt;/dependency&gt;
</pre>
<p>Ovo vrijedi samo ako se koristi Maven build tool. Ako se koristi Gradle proces je sličan samo što se zavisnost mora dodati u drugu datoteku i kod koji se mora dodati izgleda drugačije. Međutim Spring podrška savjetuje korištenje Maven build tool-a.
</p><p><br />
</p>
<h2> <span class="mw-headline" id="Rad_sa_Spring_Security_okvirom"> Rad sa Spring Security okvirom </span></h2>
<p>Nakon što je projekt kreiran i nakon što su dodane potrebne zavisnosti, moguće je pokrenuti projekt. Naime, samo dodavanjem zavisnosti za Spring Security u projekt, automatski se dodaju određene sigurnosne značajke bez potrebe da ih programer sam implementira. Jedna od tih značajki je sljedeća.
Prilikom samog pokretanja aplikacije, ako upišemo u web preglednik localhost:8080 (automatski je postavljeno da se koristi port 8080) prikazati će nam se defaultni Springov autentikacijski okvir koji će nas tražiti za korisničko ime i šifru kako bi smo mogli pristupiti sadržaju stranice. <strong>Username</strong> je po defaultu postavljen na "user" dok <strong>Password</strong> možemo saznati iz konzole IDEA(šifra se ponovo generira svakim pokretanjem aplikacije).
</p><p><a href="http://security.foi.hr/wiki/index.php/Datoteka:Localhost.png" class="image"><img alt="Localhost.png" src="../images/thumb/5/5d/Localhost.png/1000px-Localhost.png" width="1000" height="541" /></a>
</p><p><br />
</p><p><a href="http://security.foi.hr/wiki/index.php/Datoteka:Default_password.png" class="image"><img alt="Default password.png" src="../images/thumb/4/4d/Default_password.png/1000px-Default_password.png" width="1000" height="249" /></a>
</p><p><br />
U nastavku će biti prikazano kako izmjeniti defaultne postavke Spring Security okvira tako da ga prilagodimo našim potrebama te da sami implementiramo svoj autentifikacijski i autorizacijski mehanizam. No prije nego što krenemo na to prikazat ćemo i objasniti ERA model baze podataka i klase potrebne za rad s njima.
</p>
<h2> <span class="mw-headline" id="Baza_podataka"> Baza podataka </span></h2>
<p>Kako planiramo napraviti kompletno rješenje autentifikacije i autorizacije, potrebno je realizirati i bazu podataka u koju ćemo moći spremati potrebne podatke za uspješno obavljanje tih dvaju procesa. Potrebno je napomenuti da se isto može napraviti bez perzistentne memorije već se može ukomponirati u radnu memoriju, međutim ta memorija nam je dostupna samo dok radi računalo(server) na kojem se vrti računalo tako da takav pristup nije pouzdan te se ne preporučuje.
</p><p><a href="http://security.foi.hr/wiki/index.php/Datoteka:ERA_model.png" class="image"><img alt="ERA model.png" src="../images/e/e0/ERA_model.png" width="1000" height="396" /></a>
</p><p>Baza se sastoji od 5 tablica:
</p>
<ul>
<li>
<strong>Users</strong> - tablica u koju se spremaju podaci o korisnicima
<ul>
<li>id - primarni ključ (int)</li>
<li>email - email korisnika koji ujedno predstavlja korisničko ime (varchar[255])</li>
<li>first_name  ime korisnika (varchar[100])</li>
<li>last_name - prezime korisnika (varchar[100])</li>
<li>password - šifra korisnika (varchar[60])</li>
<li>enabled - zastavica da li je račun aktiviran (bool)</li>
<li>using_two_factor_authentication - zastavica za korištenje dvofaktorske autentifikacije (bool)</li>
<li>two_factor_authentication_secret - tajni ključ koji se koristi za dvofaktorsku autentifikaciju</li>
</ul>
</li>
<li>
<strong>Roles</strong> - Tablica mogućih uloga u aplikaciji (Moguće uloge: User, Moderator, Administrator)
<ul>
<li>id - primarni ključ (int)</li>
<li>type - tip uloge (varchar[255]) (varchar</li>
</ul>
</li>
<li>
<strong>User_type</strong> - tablica slabog entiteta koja povezuje korisnika s određenom ulogom
<ul>
<li>role_id - vanjski ključ na tablicu "roles" (int)</li>
<li>user_id - vanjski ključ na tablicu "users" (int)</li>
</ul>
</li>
<li>
<strong>Password_reset_token</strong> - tablica za pohranu tokena koji se koriste u svrhu autentifikacije korisnikove akcije resetiranja šifre računa
<ul>
<li>user_id - vanjski ključ na tablicu "users" (int)</li>
<li>token - vrijednost generiranog tokena (text)</li>
<li>expiry_date - vrijeme isteka tokena (timestamp)</li>
</ul>
</li>
<li><strong>Verification_token</strong> - isto kao i tablica "password_reset_token" samo što se u ovu tablicu spremaju tokeni potrebni za verifikaciju korisnika</li>
</ul>
<p>Kako smo naveli da koristimo Hibernate ORM okvir, potrebno je implementirati i određene klase u samom projektu koje će  predstavljati entitete u bazi podataka. Potrebne klase su redom:
</p>
<h3> <span class="mw-headline" id="User">User</span></h3>
<pre>
@Entity
@Table(name=&quot;user_profile&quot;, schema = &quot;public&quot;)
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    @Column(name = &quot;id&quot;)
    private long id;
    @Column(name=&quot;first_name&quot;)
    private String firstName;
    @Column(name=&quot;last_name&quot;)
    private String lastName;
    @Column(name=&quot;email&quot;)
    private String email;
    @Column(name=&quot;password&quot;)
    private String password;
    @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.EAGER)
    @JoinTable(name =&quot;user_role&quot;, joinColumns = @JoinColumn(name = &quot;id_user&quot;), inverseJoinColumns = @JoinColumn(name = &quot;id_role&quot;))
    private Set&lt;Role&gt; roles;
    @Column(name=&quot;enabled&quot;)
    private boolean enabled;
    @Column(name=&quot;using_two_factor_authentication&quot;)
    private boolean isUsing2FA;
    @Column(name = &quot;two_factor_authentication_secret&quot;)
    private String secret;

    public User(){
        super();
        this.secret = Base32.random();
    }

    public User(User user) {
        this.id = user.getId();
        this.firstName = user.getFirstName();
        this.lastName = user.getLastName();
        this.email = user.getEmail();
        this.password = user.getPassword();
        this.roles = user.getRoles();
        this.enabled = user.isEnabled();
        this.isUsing2FA = user.isUsing2FA();
    }

    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public Set&lt;Role&gt; getRoles() {
        return roles;
    }

    public void setRoles(Set&lt;Role&gt; roles) {
        this.roles = roles;
    }

    public boolean isEnabled() {
        return enabled;
    }

    public void setEnabled(boolean enabled) {
        this.enabled = enabled;
    }

    public boolean isUsing2FA() {
        return isUsing2FA;
    }

    public void setUsing2FA(boolean using2FA) {
        isUsing2FA = using2FA;
    }

    public String getSecret() {
        return secret;
    }

    public void setSecret(String secret) {
        this.secret = secret;
    }
    
}
</pre>
<h3> <span class="mw-headline" id="Role">Role</span></h3>
<pre>
@Entity
@Table(name=&quot;role&quot;, schema = &quot;public&quot;)
public class Role {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    @Column(name=&quot;id&quot;)
    private long roleId;

    @Column(name=&quot;type&quot;)
    private String type;

    public long getRoleId() {
        return roleId;
    }

    public void setRoleId(int roleId) {
        this.roleId = roleId;
    }

    public String getRole() {
        return type;
    }

    public void setRole(String type) {
        this.type = type;
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }
}
</pre>
<h3> <span class="mw-headline" id="VerificaitonToken">VerificaitonToken</span></h3>
<pre>
@Entity
@Table(name=&quot;verification_token&quot;, schema = &quot;public&quot;)
public class VerificationToken {
    private static final int EXPIRATION = 24; //Hours

    @Id
    //We need to define new generator because we want out primary key to
    //be same as primary key of table &quot;user_profile&quot; that is class/Entity User
    @GeneratedValue(generator = &quot;newGenerator&quot;)
    @GenericGenerator(name =&quot;newGenerator&quot;, strategy = &quot;foreign&quot;,
            parameters = {@org.hibernate.annotations.Parameter(value=&quot;user&quot;, name=&quot;property&quot;)})//value -&gt; name of class/Entity
    private Long id;

    @Column(name=&quot;token&quot;)
    private String token;

    @OneToOne(targetEntity = User.class, fetch = FetchType.EAGER)
    @JoinColumn(nullable = false, name = &quot;id&quot;)
    private User user;

    @Column(name=&quot;expiry_date&quot;)
    private LocalDateTime expiryDate;

    public VerificationToken(String token, User user, LocalDateTime registerDate) {
        this.token = token;
        this.user = user;
        this.expiryDate = registerDate.plusHours(EXPIRATION);
    }

    private Date calculateExpiryDate(int expiryTimeInMinutes){
        Calendar cal = Calendar.getInstance();
        cal.setTime(new Timestamp(cal.getTime().getTime()));
        cal.add(Calendar.MINUTE, expiryTimeInMinutes);
        return new Date(cal.getTime().getTime());
    }

    public VerificationToken(){}

    public static int getEXPIRATION() {
        return EXPIRATION;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getToken() {
        return token;
    }

    public void setToken(String token) {
        this.token = token;
    }

    public User getUser() {
        return user;
    }

    public void setUser(User user) {
        this.user = user;
    }

    public LocalDateTime getExpiryDate() {
        return expiryDate;
    }

    public void setExpiryDate(LocalDateTime expiryDate) {
        this.expiryDate = expiryDate.plusHours(EXPIRATION);
    }

    public void updateToke(String token) {
        this.token = token;
    }
}
</pre>
<h3> <span class="mw-headline" id="PasswordResetToken">PasswordResetToken</span></h3>
<pre>
@Entity
public class PasswordResetToken {
    private static final int EXPIRATION = 60*24;

    @Id
    //We need to define new generator because we want out primary key to
    //be same as primary key of table &quot;user_profile&quot; that is class/Entity User
    @GeneratedValue(generator = &quot;newGenerator&quot;)
    @GenericGenerator(name =&quot;newGenerator&quot;, strategy = &quot;foreign&quot;,
            parameters = {@org.hibernate.annotations.Parameter(value=&quot;user&quot;, name=&quot;property&quot;)})//value -&gt; name of class/Entity
    private Long id;

    @Column(name = &quot;token&quot;)
    private String token;

    @OneToOne(targetEntity = User.class, fetch = FetchType.EAGER)
    @JoinColumn(nullable =  false, name = &quot;id&quot;)
    private User user;

    @Column(name=&quot;expiry_date&quot;)
    private LocalDateTime expiryDate;

    public PasswordResetToken() {}

    public PasswordResetToken(String token, User user) {
        this.token = token;
        this.user = user;
        this.expiryDate = LocalDateTime.now().plusHours(EXPIRATION);
    }


    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getToken() {
        return token;
    }

    public void setToken(String token) {
        this.token = token;
    }

    public User getUser() {
        return user;
    }

    public void setUser(User user) {
        this.user = user;
    }

    public LocalDateTime getExpiryDate() {
        return expiryDate;
    }

    public void setExpiryDate(LocalDateTime expiryDate) {
        this.expiryDate = expiryDate.plusHours(EXPIRATION);
    }
}
</pre>
<p><br />
Također osim samih klasa koji predstavljaju entitete tj. tablice u bazi podataka potrebno je zbog korištenja ORM okvira implementirati i <strong>Repozitorije</strong>. Repozitoriji čine sučelja koji su vezani za modele, a služe kao posrednici za komunikaciju s bazom podataka tj. za preslikavanje entiteta u modele i obratno. Pod tim preslikavanjem podrazumjevamo i obavljanje CRUD operacija. U aplikaciji se koriste četiri repozitorija:
</p>
<h3> <span class="mw-headline" id="UserRepository">UserRepository</span></h3>
<pre>
public interface UserRepository extends JpaRepository&lt;User, Long&gt; {
    Optional&lt;User&gt; findByEmail(String username);
}
</pre>
<h3> <span class="mw-headline" id="RoleRepository">RoleRepository</span></h3>
<pre>
public interface RoleRepository extends JpaRepository&lt;Role, Long&gt;{
    Role findByType(String type);
}
</pre>
<h3> <span class="mw-headline" id="VerificationTokenRepository">VerificationTokenRepository</span></h3>
<pre>
public interface VerificationTokenRepository extends JpaRepository&lt;VerificationToken, Long&gt; {

    VerificationToken findByToken(String token);
    VerificationToken findByUser(User user);
}
</pre>
<h3> <span class="mw-headline" id="PasswordResetTokenRepository">PasswordResetTokenRepository</span></h3>
<pre>
public interface PasswordResetTokenRepository extends JpaRepository&lt;PasswordResetToken, Long&gt; {
    PasswordResetToken findByToken(String token);
    PasswordResetToken findById(long id);
}
</pre>
<p>Nakon što je ovo objašnjeno možemo kreniti na dio sa zaštitom aplikacije.
</p><p><br />
</p>
<h2> <span class="mw-headline" id="Za.C5.A1tita_aplikacije"> Zaštita aplikacije </span></h2>
<p>Postoji više točaka zaštite aplikacije. Ovdje će se obraditi točke:
</p>
<ul>
<li>Registracije, aktivacije računa, verifikacijski mail, kriptiranja lozinke i resetiranja lozinke računa</li>
<li>Autentifikacijski proces, prijavljivanje/odjave u/iz aplikaciju, rad s ulogama</li>
<li>Postavljanje sigurnosnih postavki u Spring Security-u</li>
<li>Rad sa sesijama i njihovo osiguravanje</li>
<li>Implementacija zaštita protiv XSS, CSRF, Clickjacking-a, Session fixation, Brute force napada i slično</li>
</ul>
<h3> <span class="mw-headline" id="Postavljanje_sigurnosne_konfiguracije">Postavljanje sigurnosne konfiguracije</span></h3>
<p>Najvažnija klasa u programu za sigurnost je klasa <strong>WebSecurityConfigureAdapter</strong>. Ta klasa pripada Spring Security okviru i potrebno ju je naslijediti u svojoj klasi koja će koristiti njene metode i atribute za postavljanja vlastite sigurnosne konfiguracije.
</p>
<pre>
@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
  
    @Autowired
    private CustomAuthenticationProvider authProvider;
 
    @Override
    protected void configure(
      AuthenticationManagerBuilder auth) throws Exception {
        auth.authenticationProvider(authProvider);
    }
 
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests().anyRequest().authenticated()
            .and()
            .httpBasic();
    }
}
</pre>
<p>Kao što možemo vidjeti iz primjera klase, naša vlastita klasa SecurityConfig koja nasljeđuje prethodno navedenu klasu WebSecurityConfigureAdapter prepisuje (eng. Override) jednu njenu metodu i to metodu <strong>configure</strong>. U jednom slučaju onda za paramtera prima <strong>AuthenticationManagerBuilder</strong>, a u drugom <strong>HttpSecurity</strong>.
</p><p>Tu je sada ono di dolazi zanimljivi dio. Ukoliko programer želi, može defaultni <strong>AuthenticationProvider</strong> zamjeniti svojim vlastitim što je u ovom primjeru i učinjeno. Vlastiti <strong>CustomAuthenticationProvider</strong> je tehnikom injektiranja(@Autowired) prosljeđen <strong>AuthenticationManagerBuilderu</strong>.
</p>
<h3> <span class="mw-headline" id="CustomAuthenticationProvider">CustomAuthenticationProvider</span></h3>
<p>U vlastitom autentifikacijskom poslužitelju moguće je implementirati vlastitu logiku autentifikacije kao što su provjera akreditiva, dvo faktorske prvojere, provjera tokena i tomu slično (ovisno što nam treba). U projektu se koristi ovaj implementacija autentifikacijskog poslužitelja koja provjerava baš te stvari i ovisno o uspješnosti provjere podiže iznimke koje se potom dalje obrađuju ili nam vraća novi objekt <strong>UsernamePasswordAuthenticationToken</strong> kojem prosljeđujemo objekt korisnika, akreditiva i njegove ovlasti tj. dodjeljene uloge za aplikaciju.
</p>
<pre>
public class CustomAuthenticationProvider extends DaoAuthenticationProvider{
    @Autowired
    private UserRepository userRepository;


    @Override
    public Authentication authenticate(Authentication auth) throws AuthenticationException {
        final String verificationCode = ((CustomWebAuthenticationDetails)auth.getDetails()).getVerificationCode();
        final Optional&lt;User&gt; optionalUser = userRepository.findByEmail(auth.getName());
        if(!optionalUser.isPresent()){
            throw new BadCredentialsException(&quot;Invalid username or password&quot;);
        }
        User user = optionalUser.get();
        if(user.isUsing2FA()){
            final Totp totp = new Totp(user.getSecret());
            if(!isValidLong(verificationCode) ||&#160;!totp.verify(verificationCode)){
                throw new BadCredentialsException(&quot;Invalid verification code&quot;);
            }
        }

        final Authentication result = super.authenticate(auth);
        return new UsernamePasswordAuthenticationToken(optionalUser.get(), result.getCredentials(), result.getAuthorities());
    }

    private boolean isValidLong(String verificationCode) {
        try{
            Long.parseLong(verificationCode);
        }catch (final NumberFormatException e){
            return false;
        }
        return true;
    }

    @Override
    public boolean supports(Class&lt;?&gt; authentication) {
        return authentication.equals(UsernamePasswordAuthenticationToken.class);
    }
}
</pre>
<h3> <span class="mw-headline" id="HttpSecurity">HttpSecurity</span></h3>
<p>Drugi dio u <strong>SecurityConfig</strong> klasi, odnosi se na <strong>HttpSeucirty</strong>. U već navedenoj metodi <strong>configure(HttpSecurity https)</strong> moguće je nad prosljeđenim objektom raditi određene preinake. Neke od tih preinaka su sljedeće:
</p>
<ul>
<li>Omogućavanje/onesposobljavanje određenih mehanizama zaštite (primjerice zaštita protiv CSRF-a)</li>
<li>Definiranje rada sa sesijama. Definiranje broja mogućih sesija po korisniku, definiranja politike kreiranja sesije, trajanja i tome slično</li>
<li>Postavljanje HTTPS-a ili djelomično postavljanje HTTPS-a (samo za neke zahtjeve je forsira korištenje HTTPS-a)</li>
<li>Postavljanje potrebe autorizacije za zahtjeve</li>
<li>Postavljanje vlastitog logina/logout i rukovatelja (eng. handlers) za uspješnu/neuspješnu operaciju</li>
<li>Rad s kolačićima</li>
<li>I još mnogo toga</li>
</ul>
<p>Primjer jedne takve konfiguracije je prikazana u sljedećem programskom isječku.
</p>
<pre>
@Override
    protected void configure(HttpSecurity http) throws Exception {
        http.csrf()
                .ignoringAntMatchers(&quot;/user/registration*&quot;,&quot;/user/exist*&quot;);
        http.sessionManagement()
                .invalidSessionUrl(&quot;/invalidSession&quot;)
                .maximumSessions(1).sessionRegistry(sessionRegistry())
                .and()
                .sessionFixation().migrateSession();
        http.requiresChannel()
                .anyRequest().requiresSecure();
        http.authorizeRequests()
                .antMatchers(&quot;/login*&quot;,&quot;/registrationConfirm**&quot;,&quot;/badUser**&quot;,&quot;/user/registration*&quot;,
                        &quot;/emailError*&quot;,&quot;/resources/**&quot;,&quot;/successRegister*&quot;,&quot;/successRegister*&quot;, &quot;/user/exist*&quot;,
                        &quot;/user/resendRegistrationToken&quot;,&quot;/forgetPassword&quot;, &quot;/user/resetPassword*&quot;,&quot;/user/changePassword*&quot;,
                        &quot;/qrcode*&quot;,&quot;/twoFactorSettings*&quot;, &quot;/logout*&quot;,
                        &quot;/css/**&quot;, &quot;/js/**&quot;, &quot;/images/**&quot;,&quot;/resources/**&quot;).permitAll()
                .antMatchers(&quot;/anonymous*&quot;).anonymous()
                .antMatchers(&quot;/user/updatePassword&quot;,&quot;/user/savePassword*&quot;, &quot;/updatePassword*&quot;).hasAuthority(&quot;CHANGE_PASSWORD_PRIVILEGE&quot;)
                .anyRequest().authenticated()
                .and()
                    .formLogin()
                        .loginPage(&quot;/login&quot;)
                        .defaultSuccessUrl(&quot;/index&quot;)
                        .failureUrl(&quot;/login?error=true&quot;)
                        .failureHandler(myAuthenticationFailureHandler)
                        .successHandler(myAuthenticationSuccessHandler)
                        .authenticationDetailsSource(authenticationDetailsSource)
                .and()
                .logout()
                    .logoutSuccessHandler(myCustomLogoutSuccessHandler)
                    .invalidateHttpSession(true)
                    .deleteCookies(&quot;JSESSIONID&quot;)
                    .permitAll();
    }
</pre>
<p>Prvo i najvažnije pravilo, <strong>većina zaštitnih mehanizama je automatski omoguće te ih nije potrebno samostalno omogućavati</strong> ali je zato moguće i većinom potrebno definirati vlastite postavke ukoliko ne želimo koristiti defaultne postavke. Također je svaku zaštitu moguće i isključiti tako da primjerice napišemo <i>http.&lt;vrsta_zastite&gt;().disable()</i> međutim to nije preporučeno. 
</p>
<h4> <span class="mw-headline" id="CSRF_za.C5.A1tita">CSRF zaštita</span></h4>
<p>Primjer jedne takve zaštite koja je uključena je zaštita za <strong>CSRF (Cross site request forgerey)</strong> napad koji prisiljava korisnika da izvrši neželjene akcije unutar aplikacije u koju je prijavljen. Međutim da bi ova zaštita funkcionirala potrebno je i na frontend-u (ono što korisnik vidi) implementirati korištenje csrf tokena kod rađenja bilo kakvog <strong>HTTP zahtjeva</strong>od strane autentificiranog korisnika.
</p><p>Primjer korištenja csrf tokena na frontendu dan je sljedećim isječkom. Potrebno je spomenuti da je korište <strong>Thymeleaf</strong> kao server-side java template engine koji kao i svaki drugi ima svoje neke posebnosti. Dani isječak pokazuje kako možemo kod korištenja forme za prijavljivanje u aplikaciju koristiti tj. prosljediti tokene.
</p>
<pre>
&lt;form  th:action=&quot;@{/login} + '?' + ${_csrf.parameterName} + '=' + ${_csrf.token}&quot; method=&quot;post&quot; class=&quot;login-form&quot;&gt;
            &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot; placeholder=&quot;username&quot;/&gt;
            &lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;password&quot;/&gt;
            &lt;input type=&quot;text&quot; name=&quot;code&quot; placeholder=&quot;Google Authenticator Verification Code&quot;/&gt;
            &lt;button type=&quot;submit&quot; &gt;login&lt;/button&gt;

            &lt;p id=&quot;forgot-password&quot; class=&quot;message forgot-password&quot;&gt;Forgot password? &lt;strong&gt;&lt;a th:href=&quot;@{/forgetPassword}&quot; th:text=&quot;#{message.forgotPassword}&quot;&gt;reset&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
            &lt;p id = &quot;create-account&quot; class=&quot;message create-account&quot;&gt;Not registered? &lt;strong&gt;&lt;a th:href=&quot;@{/user/registration}&quot;&gt;Create an account&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

            &lt;div th:if=&quot;${param.logSucc}&quot; class=&quot;alert alert-warning login-message&quot;&gt;
                &lt;strong&gt;&lt;p th:text=&quot;#{message.logoutSucc}&quot;&gt;&lt;/p&gt;&lt;/strong&gt;
            &lt;/div&gt;
            &lt;!--&lt;div th:if=&quot;${param.error&#160;!= null}&quot;
                 th:text=&quot;${session[SPRING_SECURITY_LAST_EXCEPTION]}&quot;&gt;error
            &lt;/div&gt;--&gt;
            &lt;div th:if=&quot;${message}&quot; class=&quot;alert alert-warning login-message&quot; &gt;
                &lt;strong&gt;&lt;p th:text=&quot;${message}&quot;&gt;&lt;/p&gt;&lt;/strong&gt;
            &lt;/div&gt;
        &lt;/form&gt;
</pre>
<p>Najvažniji dio u ovom isječku je <i>&lt;form  th:action="@{/login} + '?' + ${_csrf.parameterName} + '=' + ${_csrf.token}" method="post" class="login-form"</i> u kojem vidimo parametre _csrf.parameterName i _csrf.token. <strong>_csrf.parameterName</strong> predstavlja HTTP zaglavlje ("X-CSRF-TOKEN") koje je potrebno uključiti u HTTP zahtjev, dok <strong>_csrf.parameterName</strong> predstavlja samu vrijednost tokena dobivenog od servera. Kod slanja zahtjeva, server uspoređuje dobiven token sa dodjeljenim i ako se poklapaju dopušta izvođenje akcije. Time je su spriječeni CSRF napadi.
Isto se može primjeniti i kod ajax poziva. Kod ajax poziva potrebno je dodati atribut headers te definirati naziv i vrijednost tokena.<br /> <strong><i>headers: {"X-CSRF-TOKEN": token}</i></strong>
</p>
<pre>
  $.ajax({
                type: &quot;POST&quot;,
                url: serverContext+&quot;/user/resetPassword&quot;,
                headers: {&quot;X-CSRF-TOKEN&quot;: token},
                data:{
                    email:email
                },
                success: function(data) {
                    window.location.replace(serverContext+&quot;/login?message=&quot;+data.message);
                },
                error:function (data){
                    if(data.responseJSON.error.indexOf(&quot;MailError&quot;)&gt;-1){
                        window.location.replace(serverContext+&quot;/emailError.html&quot;);
                    }
                    else{
                        window.location.replace(serverContext+&quot;/login?message=&quot;+data.responseJSON.message);
                    }
                }
            });
</pre>
<h4> <span class="mw-headline" id="HTTPS">HTTPS</span></h4>
<p>Po defaultu Spring Security ne forsira korištenje HTTPS-a, stoga je to zaštita koju treba ručno uključiti. Ona se uključuje naredbom <strong><i>http.requiresChannel().anyRequest().requireSecure()</i></strong>. Poziv metode <strong>.anyRequest()</strong> forsira da se za svaki primjeni određena konfiguracija dok metoda <strong>requireSecure()</strong> forsira korištenje HTTPS-a. Ovom konfigracijom svaki zahtjev zahtjevat će korištenje HTTPS-a. To je dobro jer time postižemo sigurnost integriteta podataka jer će se podaci koji se prenose preko mreže biti kriptirani. Također, moguće je definirati za koje sve zahtjeve želimo da se koristi https. To radimo pomoću poziva metode <strong>.antMatchers()</strong> u kojoj navodimo url koji želimo da se uzme u obzir. Međutim nešto više o tome malo poslje.
</p><p>Međutim da bi ovo funkcioniralo, server na kojem se nalazi aplikacija mora moći posluživati HTTPS stranice. Što znači da SSL/TLS podrška mora biti uključena. To pak znači da se mora koristiti valjani i ovjereni certifikat ili ako se koristi u svrhe testiranja moguće je generirati svoj vlastiti potpisani certifikat.
</p><p>Ako ćemo koristiti vlastiti, potrebno je prvo generirati ključeve što se može napraviti izvođenjem sljedeće komande u terminualu:
<strong><i>keytool -genkey -alias tomcat -keyalg RSA -storepass changeit -keypass changeit -dname 'CN=tomcat'</i></strong>
ova naredva stvoriti će privatni ključ i vlastito potpisani certifikat.
Sljedeće što je potrebno napraviti je ažurirati konfiguraciju servera što možemo učiniti ako koristimo Tomcat server u folderu <strong>conf/server.xml</strong>. Preinake koje su potrebne učiniti navedene su sljedećim isječkom.
</p>
<pre>
&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;
   connectionTimeout=&quot;20000&quot;
   redirectPort=&quot;8443&quot; /&gt;
 
&lt;Connector port=&quot;8443&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot;
   maxThreads=&quot;150&quot; SSLEnabled=&quot;true&quot; scheme=&quot;https&quot; secure=&quot;true&quot;
   clientAuth=&quot;false&quot; sslProtocol=&quot;TLS&quot;
   keystoreFile=&quot;${user.home}/.keystore&quot; keystorePass=&quot;changeit&quot; /&gt;
</pre>
<p>Slične izmjene potrebno je napraviti i za druge servere.
</p><p>Međutim, Spring projekt dolazi s embedded Tomcat serverom te nije potrebno koristiti zasebni server za pokretanje aplikacije. U tom slučaju nije potrebno mjenjati server.xml datoteku jer ona ne postoji već je dovoljno u <strong>application.properties</strong> navesti sljedeće postavke:
</p>
<pre>
#HTTPS
server.port=8443
server.ssl.key-store=springbootKeystore.p12
server.ssl.key-store-password=47184718
server.ssl.key-store-type=PKCS12
server.ssl.key-alias=springboot
</pre>
<ul>
<li><strong>server.port</strong> - definiramo na kojem se portu aplikacija vrti (8443 je standardni port koji se koristi za https)</li>
<li><strong>server.ssl.key-store</strong> - definiramo naziv datoteke u kojem se nalazi certifikat</li>
<li><strong>server.ssl.key-store</strong> - definiramo naziv datoteke u kojem se nalazi certifikat</li>
<li><strong>server.ssl.key-store-password</strong> - šifra ključa (potrebno je navesti istu onu koja se definirala u procesu kreiranja ključeva i certifikata)</li>
<li><strong>server.ssl.key-store-type=PKCS12</strong> - tip datoteke</li>
<li><strong>server.ssk.key-alias</strong> - naziv pod kojim je spremljen</li>
</ul>
<p>Naravno da bi ovo radilo potrebno je key-store datoteku uključiti u projekt kako bi Spring mogao pronaći datoteku. Nakon što smo sve ovo napravili, aplikacija bi trebala moći koristiti HTTPS kanal. Međutim ostaje još problem preusmjeravanja HTTP prometa na HTTPS. To možemo učiniti pomoću dodatne konfiguracijske klase, nazvat ćemo ju <strong>WebContainerConfig</strong>, a njezina implementacija dana je sljedećim isječkom.
</p>
<pre>
@Configuration
public class WebContainerConfig {

    @Bean
    public EmbeddedServletContainerFactory embeddedServletContainerFactory(){
        TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory = new TomcatEmbeddedServletContainerFactory(){
            @Override
            protected void postProcessContext(Context context) {
                SecurityConstraint constraint = new SecurityConstraint();
                constraint.setUserConstraint(&quot;CONFIDENTIAL&quot;);
                SecurityCollection collection = new SecurityCollection();
                collection.addPattern(&quot;/*&quot;);
                constraint.addCollection(collection);
                context.addConstraint(constraint);
            }
        };

        tomcatEmbeddedServletContainerFactory.addAdditionalTomcatConnectors(createSslConnector());
        return tomcatEmbeddedServletContainerFactory;
    }

    private Connector createSslConnector() {
        Connector connector = new Connector(&quot;org.apache.coyote.http11.Http11NioProtocol&quot;);
        connector.setScheme(&quot;http&quot;);
        connector.setPort(8080);
        connector.setRedirectPort(8443);
        connector.setSecure(false);

        return connector;
    }
}
</pre>
<p>U metodi <strong>createSslConnector()</strong> možemo vidjeti proces redirekcije s porta 8080 koji koristi http na port 8443 koji koristi HTTPS. Time je proces implementacije korištenja HTTPS-a gotov.
</p>
<h4> <span class="mw-headline" id="Rad_sa_sesijama">Rad sa sesijama</span></h4>
<p>Pozivom metode <strong>http.sessionManagement()</strong> omogućava nam definiranje postavka sesija. Tako možemo postaviti maksimalni broj sesija za pojedinog korisnika <strong><i>.maximuSession()</i></strong> ili možemo uključiti zaštitu protiv napada fiksiranja sesija pozivom metode <strong><i>.sessionFixation().migrateSession()</i></strong>. Ova postavka omogućuje da se prilikom ponovog autentificiranja korisnika staru sesiju proglasi nevažećom te se atributi iz stare sesije prepišu u novu. Naravno postoji mogućnost i <strong><i>.newSession</i></strong> u kojem se svaki put stvara nova čista sesija bez da se atributi iz stare serije prepisuju u novu.
</p><p>Također dobra praksa zaštite sesija je spriječiti korištenje URL parametara za praćenje sesija. Ovaj sigurnosni rizik bio je na OWASP top 10 popisu do čak 2013. godine. Da bi smo ovaj sigurnosni rizik  izbjegli potrebno je definirati drugačiji način praćenja sesija. To možemo učiniti sljedećom naredbom <strong><i>servletContextEvent.getServletContext().setSessionTrackingModes(EnumSet.of(SessionTrackingMode.COOKIE))</i></strong>  kojom definiramo kolačić kao sredstvo praćenja sesije ili možemo navesti SSL kao sredstvo praćenja <strong><i>servletContextEvent.getServletContext().setSessionTrackingModes(EnumSet.of(SessionTrackingMode.SSL))</i></strong> umjesto URL koji se smatra najlošijim način za praćenje sesija.
</p>
<pre>
@WebListener
public class SessionTrackingModeConfig implements ServletContextListener {
    @Override
    public void contextInitialized(ServletContextEvent servletContextEvent) {
        servletContextEvent.getServletContext().setSessionTrackingModes(EnumSet.of(SessionTrackingMode.SSL));
    }

    @Override
    public void contextDestroyed(ServletContextEvent servletContextEvent) {

    }
}
</pre>
<h4> <span class="mw-headline" id="Autorizacija_zahtjeva">Autorizacija zahtjeva</span></h4>
<p>Sljedeće na redu je osiguravanje samih zahtjeva odnosno postavljanje autorizacije. Opet kao i prije koristimo prosljeđeni HttpSecurity objekt za daljnje modificiranje i opet kao prije možemo postaviti pravilo koje će se odnositi na sve zahtjeve napravljenje od strane korisnika ili možemo pomoću metode <strong>.antMatchers()</strong> definirati template za koje zahtjeve želimo da se određeno pravilo primjeni. Postoje više vrsta mogućih autorizacija, a to su:
</p>
<ol>
<li>.permitAll() - svima je dopušten pristup</li>
<li>.anonymous() - dopušten je pristup samo anonimnim korisnicima.</li>
<li>.authenticated() - dopušten je pristup samo autentificiranim korisnicima</li>
<li>.hasAuthority(String authority) - dopušten je pristup samo korisnicima kojima je dodjeljena određena prava. Pod pravima mislimo pravo za čitanje, pisanje,
 izvršavanje i tomu slično,</li>
<li>.access() - dozvoljavanje pristupa određenim resursima</li>
<li>.denyAll() - pristup je zabranjen svima</li>
<li>.fullyAuthenticated() - slično kao i .authenticated() samo što provjerava još da li korisnik ima označenu opciju "Zapamti me"</li>
<li>.hasAnyAuthority() - dopušten je pristup korisnicima koji imaju dodjeljenu bilo kakvu ovlast</li>
<li>.hasAnyRole() - dopušten je pristup korisnicima koji imaju dodjeljenu bilo kakvu ulogu</li>
<li>.hasRole(String role) - dopušten je pristup korisnicima koji imaju određenu ulogu</li>
<li>.hasIpAddress() - dopušten je pristup korisnicima s određenom IP adresom</li>
<li>.rememberMe() - dopušten je pristup korisnicima koji koriste opciju "Zapamti me" prilikom prijave u aplikaciju</li>
<li>.not()</li>
</ol>
<p>Primjer korištenje jednog takvog pravila dan je sljedećim isječkom.
</p>
<pre>
http.authorizeRequests()
                .antMatchers(&quot;/login*&quot;,&quot;/registrationConfirm**&quot;,&quot;/badUser**&quot;,&quot;/user/registration*&quot;,
                        &quot;/emailError*&quot;,&quot;/resources/**&quot;,&quot;/successRegister*&quot;,&quot;/successRegister*&quot;, &quot;/user/exist*&quot;,
                        &quot;/user/resendRegistrationToken&quot;,&quot;/forgetPassword&quot;, &quot;/user/resetPassword*&quot;,&quot;/user/changePassword*&quot;,
                        &quot;/qrcode*&quot;,&quot;/twoFactorSettings*&quot;, &quot;/logout*&quot;,
                        &quot;/css/**&quot;, &quot;/js/**&quot;, &quot;/images/**&quot;,&quot;/resources/**&quot;).permitAll()
                .antMatchers(&quot;/anonymous*&quot;).anonymous()
                .antMatchers(&quot;/user/updatePassword&quot;,&quot;/user/savePassword*&quot;, &quot;/updatePassword*&quot;).hasAuthority(&quot;CHANGE_PASSWORD_PRIVILEGE&quot;)
                .anyRequest().authenticated();
</pre>
<h3> <span class="mw-headline" id="UserDetailService">UserDetailService</span></h3>
<p>Važna stavka kod konfiguriranja sigurnosnih postavki je i implementacija <strong>UserDetailService</strong> sučelja koje je dio Spring Security okvira. Razlog zašto je to potrebno implementirati  je zbog toga što imati više različitih korisnika koji mogu koristiti aplikaciju (pod time mislimo na vrste korisnika kao što je Admin, Moderator ili obični Korisnik). Da bi Spring mogao znati kako da se ponaša prema kojem korisniku moramo implementirati ovo sučelje u našoj vlastitoj klasi.
</p>
<pre>
@Service
public class CustomUserDetailsService implements UserDetailsService {
    @Autowired
    private UserRepository userRepository;
    @Autowired
    private LoginAttemptService loginAttemptService;
    @Autowired
    private HttpServletRequest request;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException{
        String ip = getClientIP();
        if(loginAttemptService.isBlocked(ip)){
            throw new IpBanException(&quot;Ip is blocked&quot;);
        }
        Optional&lt;User&gt; optionalUser = userRepository.findByEmail(username);

        optionalUser.orElseThrow(()-&gt;new UsernameNotFoundException(&quot;Username not found&quot;));
        return optionalUser.map(CustomUserDetails::new).get();
    }

    private final String getClientIP(){
        final String xfHeader = request.getHeader(&quot;X-Forwarded-For&quot;);
        if(xfHeader == null){
            return request.getRemoteAddr();
        }
        return xfHeader.split(&quot;,&quot;)[0];
    }
}
</pre>
<p>U klasi možemo vidjeti da se prepisuje (eng. Override) metoda <strong>loadUserByUsername(String username)</strong> koja na temelju prosljeđenog korisničkog imena doznaje o kojem se korisniku radi te se vraća UserDetails objekt (dio Spring Security-a) u kojem se ujedno nalaze i navedene uloge samog korisnika. Ukoliko korisnik ne postoji podiže se iznimka.
U ovoj metodi provjerava se još da li je određena IP adresa blokirana. Naime provjera blokiranosti IP adrese napravljena je s ciljem da se spriječi brute force napad pogađanja korisničkog imena i lozinke.
</p>
<h3> <span class="mw-headline" id="Brute_force_napad">Brute force napad</span></h3>
<p>Kao što je u sekciji iznad navedeno. Kod pokušavanja prijave korisnika u aplikaciju provjerava se da li je određena IP adresa blokirana. To je realizirano pomoću Cache-a. Za svaku IP adresu s koje se korisnik pokuša prijaviti u aplikaciju sprema se u Cache i dodjeljuju joj se pokušaji koji na početku iznosi 0. Maksimalno je moguće učiniti 10 neuspjelih pokušaja. U tom trenuktu dodjeljuje se IP adresu ban od jednog dana. U tom vremenskom periodu nije se moguće prijaviti s te IP adrese. Za Cache je korištena biblioteka Caffeine pomoću koje je moguće vrlo lako odrediti trajanje tj. čuvanje podataka u Cachu. Postoje mogućnosti za definiranje vremenskog roka od vremenske jedinice nanosekunde pa do jedinice dana.
</p>
<pre>
@Service
public class LoginAttemptService {
    private final int MAX_ATTEMPT = 10;
    private LoadingCache&lt;String, Integer&gt; attemptsCache;

    public LoginAttemptService(){
        super();
        attemptsCache =  Caffeine.newBuilder()
                .expireAfterWrite(1, TimeUnit.DAYS)
                .build(new CacheLoader&lt;String, Integer&gt;() {
                    @Override
                    public Integer load(String key) throws Exception {
                        return 0;
                    }
                });
    }

    public void loginSucceeded(String key){
        attemptsCache.invalidate(key);
    }

    public void loginFailed(String key){
        int attempts = 0;
        try{
            attempts = attemptsCache.get(key);
        }catch (Exception e){
            attempts = 0;
        }
        attempts++;
        attemptsCache.put(key,attempts);
    }

    public boolean isBlocked(String key){
        try{
            return attemptsCache.get(key)&gt;= MAX_ATTEMPT;
        }catch (Exception e){
            return false;
        }
    }
}
</pre>
<p><br />
</p>
<h3> <span class="mw-headline" id="Provjera_ja.C4.8Dine_lozinke_.28backend.29">Provjera jačine lozinke (backend)</span></h3>
<p>Moguće je definirati vlastiti predložak za provjeru jačine/ispravnosti lozinke
</p>
<pre>
public class PasswordConstraintValidator implements ConstraintValidator&lt;ValidPassword, String&gt;
{
    @Override
    public void initialize(final ValidPassword arg0) {

    }

    @Override
    public boolean isValid(final String password, final ConstraintValidatorContext context){
        final PasswordValidator validator = new PasswordValidator(Arrays.asList(
                new LengthRule(8,30),
                new CharacterRule(EnglishCharacterData.UpperCase,1),
                new CharacterRule(EnglishCharacterData.Digit,1),
                new CharacterRule(EnglishCharacterData.Special,1)
        ));

        final RuleResult result = validator.validate(new PasswordData(password));
        if(result.isValid()){
            return true;
        }

        context.disableDefaultConstraintViolation(); //prevent return of default constraint violation
        String template = String.join(&quot;,&quot;,validator.getMessages(result));
        String defaultMessage = &quot;Password too weak (minimum 8 characters, 1 uppercase, 1 number and 1 special)&quot;;
        context.buildConstraintViolationWithTemplate(defaultMessage).addConstraintViolation();
        return false;
    }
}
</pre>
<h3> <span class="mw-headline" id="Encoder_.28kriptiranje_lozinke.29">Encoder (kriptiranje lozinke)</span></h3>
<p>U samoj konfiguracijskoj klasi moguće je veoma lako postaviti vrstu enkodiranja tj. kriptiranja lozinki. U metodi <strong>configure(AuthenticationManagerBuilder auth)</strong> moguće je kreirati novi <strong>DaoAuthenticationProvider</strong> postaviti mu već spomenuti UserDetailsService i postaviti encoder. U našem slučaju korišten je <strong>BCryptPasswordEncoder</strong> sa snagom 11. Standardna snaga je 10, a što je snaga veća to je potrebna duže vrijeme, odnosno posla da se hashira lozinka (količina posla se povećava eksponencijalno). To je ujedno još jedan mehanizam za zaštitu od <strong>brute force napada</strong>.
</p>
<pre>
  @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.authenticationProvider(authProvider());
    }

 @Bean
    public DaoAuthenticationProvider authProvider(){
        final CustomAuthenticationProvider authProvider = new CustomAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService);
        authProvider.setPasswordEncoder(encoder());
        return authProvider;
    }

    @Bean
    public PasswordEncoder encoder(){
        return new BCryptPasswordEncoder(11);
    }
</pre>
<h3> <span class="mw-headline" id="Dvo_faktorska_autorizacija">Dvo faktorska autorizacija</span></h3>
<p>Kod kreiranja korisničkog računa korisniku se nudi opcija dvofaktorske autentifikacije. Inače se dvo faktorska autentifikacija implementira tako da se korisniku putem sms poruke ili putem email-a pošalje alfanumerički zapis koji potom mora upisati tijekom procesa prijave. Međutim u ovom projeku napravljo je uz pomoć QR kodova. Nakon uspješne korisnikove registracije korisniku se prikazuje QR kod koji moram skenirati pomoću google-ove Authenticator aplikacije. Nakon toga kod prijave koristi kodove koje mu aplikacije prikazuje s time da u određenom vremenskom roku mora upisati šifru.
</p><p><a href="http://security.foi.hr/wiki/index.php/Datoteka:QR_code.png" class="image"><img alt="QR code.png" src="../images/thumb/6/6b/QR_code.png/300px-QR_code.png" width="300" height="300" /></a>
</p><p>Za generiranje QRUrl potrebno je priložiti ime aplikacije, email korisnika i tajna koja mu je dodjeljena, a koristi se za generiranje QR koda.
</p>
<pre>
 public static String QR_PREFIX =&quot;https://chart.googleapis.com/chart?chs=200x200&amp;chld=M%%7C0&amp;cht=qr&amp;chl=&quot;;
 public static String APP_NAME = &quot;SecurityDemo&quot;;

 @Override
    public String generateQRUrl(User user){
        try{
            return QR_PREFIX + URLEncoder.encode(String.format(
                    &quot;otpauth://totp/%s:%s?secret=%s&amp;issuer=%s&quot;,
                    APP_NAME, user.getEmail(), user.getSecret(), APP_NAME),
                    &quot;UTF-8&quot;);
        }catch (UnsupportedEncodingException E){
            return null;
        }
    }

</pre>
<h3> <span class="mw-headline" id="Validacija_tokena_za_resetiranje_lozinke">Validacija tokena za resetiranje lozinke</span></h3>
<p>Kod provjere tokena za resetiranje lozinke provjerava se da li je token identičan tokenu koji je poslan korisniku na email i da li je istekao.
</p>
<pre>
@Service
@Transactional
public class SecurityUserService implements  ISecurityUserService{

    @Autowired
    private PasswordResetTokenRepository passwordResetTokenRepository;

    @Override
    public String validatePasswordResetToken(long id, String token) {
        PasswordResetToken passwordToken = passwordResetTokenRepository.findByToken(token);
        if((passwordToken==null) || (passwordToken.getUser().getId()&#160;!= id)){
            return &quot;invalidToken&quot;;
        }

        final LocalDateTime timeNow = LocalDateTime.now();
        if((passwordToken.getExpiryDate().isBefore(timeNow))){
            return &quot;expired&quot;;
        }

        final User user = passwordToken.getUser();
        final Authentication auth = new UsernamePasswordAuthenticationToken(user, null,
                Arrays.asList(new SimpleGrantedAuthority(&quot;CHANGE_PASSWORD_PRIVILEGE&quot;)));
        SecurityContextHolder.getContext().setAuthentication(auth);
        return null;
    }
}
</pre>
<h3> <span class="mw-headline" id="Validacija_tokena_za_verifikaciju">Validacija tokena za verifikaciju</span></h3>
<pre>
 @Override
    public String validateVerificationToken(String token) {
        final VerificationToken verificationToken = tokenRepository.findByToken(token);
        if(verificationToken == null){
            return TOKEN_INVALID;
        }

        final User user = verificationToken.getUser();
        final LocalDateTime time = LocalDateTime.now();
        if(time.isAfter(verificationToken.getExpiryDate())){
            tokenRepository.delete(verificationToken);
            return TOKEN_EXPIRED;
        }

        user.setEnabled(true);
        userRepository.save(user);
        return TOKEN_VALID;
    }
</pre>
<h3> <span class="mw-headline" id="Recaptcha">Recaptcha</span></h3>
<p>U aplikaciji se također koristi i reCaptcha sustav kako bi se spriječio spam. To je pogotovo važno koristiti kod formi koji upisuju podatke u bazu podataka kako  se nebi zlouporabilo punjenje baze podataka nepotrebnim podacima.
Kod provjere reCaptche radi se upit na <i><a href="https://www.google.com/recaptcha/api/siteverify?secret=%s&amp;response=%s&amp;remoteip=%s" class="external free" rel="nofollow">https://www.google.com/recaptcha/api/siteverify?secret=%s&amp;response=%s&amp;remoteip=%s</a></i> kojem se za parametre dodaje <strong>reCaptchaSecret</strong> koji je jedinstven za aplikaciju, <strong>resposne</strong> koji se dobije od frontend dijela reCaptche i <strong>IP adresa klijenta</strong>. Na zahtjev dobivamo <strong>GoogleResponse</strong> na temelju kojeg provjeravamo ispravnost reCaptche.
</p>
<pre>
@Service(&quot;captchaService&quot;)
public class CaptchaService implements ICaptchaService{

    @Autowired
    private HttpServletRequest request;

    @Autowired
    private CaptchaSettings captchaSettings;

    @Autowired
    private RestOperations restTemplate;

    @Autowired
    private ReCaptchaAttemptService reCaptchaAttemptService;

    private static Pattern RESPONSE_PATTER = Pattern.compile(&quot;[A-Za-z0-9_-]+&quot;);

    @Override
    public void processResponse(String response) {

        if(reCaptchaAttemptService.isBlocked(getClientIP())){
            throw new ReCaptchaInvalidException(&quot;Client exceeded maximum number of failed attempts&quot;);
        }

        if(!responseSanityCheck(response)){
            throw new ReCaptchaInvalidException(&quot;Response contains invalid characters&quot;);
        }

        URI verifyUri = URI.create(String.format(
                &quot;https://www.google.com/recaptcha/api/siteverify?secret=%s&amp;response=%s&amp;remoteip=%s&quot;,
                getReCaptchaSecret(), response, getClientIP()));

        try {
            final GoogleResponse googleResponse = restTemplate.getForObject(verifyUri, GoogleResponse.class);

            if (!googleResponse.isSuccess()) {
                if (googleResponse.hasClientError()) {
                    reCaptchaAttemptService.reCaptchaFailed(getClientIP());
                }
                throw new ReCaptchaInvalidException(&quot;reCaptcha was not successfully validated&quot;);
            }
        } catch (RestClientException rce) {
            throw new ReCaptchaUnavailableException(&quot;Registration unavailable at this time.  Please try again later.&quot;, rce);
        }
        reCaptchaAttemptService.reCaptchaSucceeded(getClientIP());
    }

    @Override
    public String getReCaptchaSite() {
        return captchaSettings.getSite();
    }

    @Override
    public String getReCaptchaSecret() {
        return captchaSettings.getSecret();
    }

    private String getClientIP(){
        final String xfHeader = request.getHeader(&quot;X-Forwarded-For&quot;);
        if(xfHeader == null){
            return request.getRemoteAddr();
        }
        return xfHeader.split(&quot;,&quot;)[0];
    }

    private boolean responseSanityCheck(String response){
        return StringUtils.hasLength(response) &amp;&amp; RESPONSE_PATTER.matcher(response).matches();
    }


    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
</pre>
<p><br />
</p>
<h2> <span class="mw-headline" id="Aplikacija"> Aplikacija </span></h2>
<p>U ovom poglavlju biti će prikazani ekrani aplikacije.<br />
<a href="http://security.foi.hr/wiki/index.php/Datoteka:SDlogin.png" class="image"><img alt="SDlogin.png" src="../images/thumb/9/91/SDlogin.png/1000px-SDlogin.png" width="1000" height="541" /></a>
<a href="http://security.foi.hr/wiki/index.php/Datoteka:SDlogin_error.png" class="image"><img alt="SDlogin error.png" src="../images/thumb/a/ac/SDlogin_error.png/1000px-SDlogin_error.png" width="1000" height="542" /></a>
<a href="http://security.foi.hr/wiki/index.php/Datoteka:SDregistration_done.png" class="image"><img alt="SDregistration done.png" src="../images/thumb/f/f5/SDregistration_done.png/1000px-SDregistration_done.png" width="1000" height="543" /></a>
<a href="http://security.foi.hr/wiki/index.php/Datoteka:SDresetPassword.png" class="image"><img alt="SDresetPassword.png" src="../images/thumb/2/23/SDresetPassword.png/1000px-SDresetPassword.png" width="1000" height="543" /></a>
<a href="http://security.foi.hr/wiki/index.php/Datoteka:SDrecovery.png" class="image"><img alt="SDrecovery.png" src="../images/thumb/6/67/SDrecovery.png/1000px-SDrecovery.png" width="1000" height="543" /></a>
<a href="http://security.foi.hr/wiki/index.php/Datoteka:SDprofile.png" class="image"><img alt="SDprofile.png" src="../images/thumb/b/bc/SDprofile.png/1000px-SDprofile.png" width="1000" height="542" /></a>
<a href="http://security.foi.hr/wiki/index.php/Datoteka:SDprofile_2.png" class="image"><img alt="SDprofile 2.png" src="../images/thumb/0/0a/SDprofile_2.png/1000px-SDprofile_2.png" width="1000" height="542" /></a>
</p>
<!-- 
NewPP limit report
Preprocessor node count: 269/1000000
Post-expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key sisds:pcache:idhash:10332-0!*!0!!hr!2!edit=0 and timestamp 20190203204151 -->
<div class="printfooter">
Dobavljeno iz "<a href="Spring_Security_framework.html">http://security.foi.hr/wiki/index.php/Spring_Security_framework</a>"</div>
				<!-- /bodytext -->
								<!-- catlinks -->
				<div id='catlinks' class='catlinks catlinks-allhidden'></div>				<!-- /catlinks -->
												<div class="visualClear"></div>
			</div>
			<!-- /bodyContent -->
		</div>
		<!-- /content -->
		<!-- header -->
		<div id="mw-head" class="noprint">
			
<!-- 0 -->
<div id="p-personal" class="">
	<h5>Osobni alati</h5>
	<ul>
					<li  id="pt-login"><a href="http://security.foi.hr/wiki/index.php?title=Posebno:Prijava&amp;returnto=Spring_Security_framework" title="Predlažemo Vam da se prijavite, ali nije obvezno. [o]" accesskey="o">Prijavi se</a></li>
			</ul>
</div>

<!-- /0 -->
			<div id="left-navigation">
				
<!-- 0 -->
<div id="p-namespaces" class="vectorTabs">
	<h5>Imenski prostori</h5>
	<ul>
					<li  id="ca-nstab-main" class="selected"><span><a href="Spring_Security_framework.html"  title="Pogledaj sadržaj [c]" accesskey="c">Članak</a></span></li>
					<li  id="ca-talk" class="new"><span><a href="http://security.foi.hr/wiki/index.php?title=Razgovor:Spring_Security_framework&amp;action=edit&amp;redlink=1"  title="Razgovor o stranici [t]" accesskey="t">Razgovor</a></span></li>
			</ul>
</div>

<!-- /0 -->

<!-- 1 -->
<div id="p-variants" class="vectorMenu emptyPortlet">
		<h5><span>Inačice</span><a href="Spring_Security_framework.html#"></a></h5>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>

<!-- /1 -->
			</div>
			<div id="right-navigation">
				
<!-- 0 -->
<div id="p-views" class="vectorTabs">
	<h5>Pogledi</h5>
	<ul>
					<li id="ca-view" class="selected"><span><a href="Spring_Security_framework.html" >Čitaj</a></span></li>
					<li id="ca-viewsource"><span><a href="http://security.foi.hr/wiki/index.php?title=Spring_Security_framework&amp;action=edit"  title="Ova stranica je zaštićena. Možete pogledati izvorni kod. [e]" accesskey="e">Vidi izvor</a></span></li>
					<li id="ca-history" class="collapsible "><span><a href="http://security.foi.hr/wiki/index.php?title=Spring_Security_framework&amp;action=history"  title="Ranije izmjene na ovoj stranici. [h]" accesskey="h">Vidi stare izmjene</a></span></li>
			</ul>
</div>

<!-- /0 -->

<!-- 1 -->
<div id="p-cactions" class="vectorMenu emptyPortlet">
	<h5><span>Radnje</span><a href="Spring_Security_framework.html#"></a></h5>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>

<!-- /1 -->

<!-- 2 -->
<div id="p-search">
	<h5><label for="searchInput">Traži</label></h5>
	<form action="http://security.foi.hr/wiki/index.php" id="searchform">
		<input type='hidden' name="title" value="Posebno:Traži"/>
				<input id="searchInput" name="search" type="text"  title="Pretraži ovaj wiki [f]" accesskey="f"  value="" />
		<input type='submit' name="go" class="searchButton" id="searchGoButton"	value="Kreni" title="Idi na stranicu s ovim imenom ako ona postoji" />
		<input type="submit" name="fulltext" class="searchButton" id="mw-searchButton" value="Traži" title="Traži ovaj tekst na svim stranicama" />
			</form>
</div>

<!-- /2 -->
			</div>
		</div>
		<!-- /header -->
		<!-- panel -->
			<div id="mw-panel" class="noprint">
				<!-- logo -->
					<div id="p-logo"><a style="background-image: url(../../images/osslogo.png);" href="../../wiki.html"  title="Glavna stranica"></a></div>
				<!-- /logo -->
				
<!-- navigation -->
<div class="portal" id='p-navigation'>
	<h5>Orijentacija</h5>
	<div class="body">
				<ul>
					<li id="n-mainpage-description"><a href="../../wiki.html" title="Posjeti glavnu stranicu [z]" accesskey="z">Glavna stranica</a></li>
					<li id="n-portal"><a href="http://security.foi.hr/wiki/index.php/SIS_Wiki:Portal_zajednice" title="O projektu, što možete učiniti, gdje je što">Portal zajednice</a></li>
					<li id="n-currentevents"><a href="http://security.foi.hr/wiki/index.php/SIS_Wiki:Novosti" title="O trenutačnim događajima">Aktualno</a></li>
					<li id="n-recentchanges"><a href="./Posebno:Nedavne_promjene.html" title="Popis nedavnih promjena u wikiju. [r]" accesskey="r">Nedavne promjene</a></li>
					<li id="n-randompage"><a href="./Posebno:Slučajna_stranica.html" title="Učitaj slučajnu stranicu [x]" accesskey="x">Slučajna stranica</a></li>
					<li id="n-help"><a href="./Pomoć:Pomoć.html" title="Mjesto za pomoć suradnicima.">Pomoć</a></li>
				</ul>
			</div>
</div>

<!-- /navigation -->

<!-- SEARCH -->

<!-- /SEARCH -->

<!-- TOOLBOX -->
<div class="portal" id="p-tb">
	<h5>Traka s alatima</h5>
	<div class="body">
		<ul>
					<li id="t-whatlinkshere"><a href="http://security.foi.hr/wiki/index.php/Posebno:%C5%A0to_vodi_ovamo/Spring_Security_framework" title="Popis svih stranica koje sadrže poveznice ovamo [j]" accesskey="j">Što vodi ovamo</a></li>
						<li id="t-recentchangeslinked"><a href="http://security.foi.hr/wiki/index.php/Posebno:Povezane_promjene/Spring_Security_framework" title="Nedavne promjene na stranicama na koje vode ovdašnje poveznice [k]" accesskey="k">Povezane stranice</a></li>
																																										<li id="t-specialpages"><a href="./Posebno:Posebne_stranice.html" title="Popis posebnih stranica [q]" accesskey="q">Posebne stranice</a></li>
									<li id="t-print"><a href="http://security.foi.hr/wiki/index.php?title=Spring_Security_framework&amp;printable=yes" rel="alternate" title="Verzija za ispis ove stranice [p]" accesskey="p">Verzija za ispis</a></li>
						<li id="t-permalink"><a href="http://security.foi.hr/wiki/index.php?title=Spring_Security_framework&amp;oldid=43737" title="Trajna poveznica na ovu verziju stranice">Trajna poveznica</a></li>
						</ul>
	</div>
</div>

<!-- /TOOLBOX -->

<!-- LANGUAGES -->

<!-- /LANGUAGES -->
			</div>
		<!-- /panel -->
		<!-- footer -->
		<div id="footer">
											<ul id="footer-info">
																	<li id="footer-info-lastmod"> Datum zadnje promjene na ovoj stranici: 22:38, 6. veljače 2018.</li>
																							<li id="footer-info-viewcount">Ova stranica je pogledana 234 puta.</li>
																							<li id="footer-info-copyright">Sadržaji se koriste u skladu s <a href="http://creativecommons.org/licenses/by-sa/3.0/" class="external ">Creative Commons Attribution Share Alike</a>.</li>
															</ul>
															<ul id="footer-places">
																	<li id="footer-places-privacy"><a href="http://security.foi.hr/wiki/index.php/SIS_Wiki:Za%C5%A1tita_privatnosti" title="SIS Wiki:Zaštita privatnosti">Zaštita privatnosti</a></li>
																							<li id="footer-places-about"><a href="./SIS_Wiki:O_projektu_SIS_Wiki.html" title="SIS Wiki:O projektu SIS Wiki">O projektu SIS Wiki</a></li>
																							<li id="footer-places-disclaimer"><a href="http://security.foi.hr/wiki/index.php/SIS_Wiki:General_disclaimer" title="SIS Wiki:General disclaimer">Odricanje od odgovornosti</a></li>
															</ul>
											<ul id="footer-icons" class="noprint">
					<li id="footer-copyrightico">
						<a href="http://creativecommons.org/licenses/by-sa/3.0/"><img src="../skins/common/images/cc-by-sa.png" alt="Creative Commons Attribution Share Alike" width="88" height="31" /></a>
					</li>
					<li id="footer-poweredbyico">
						<a href="http://www.mediawiki.org/"><img src="../skins/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" width="88" height="31" /></a>
					</li>
				</ul>
						<div style="clear:both"></div>
		</div>
		<!-- /footer -->
		
<script src="../load.php%3Fdebug=false&amp;lang=hr&amp;modules=startup&amp;only=scripts&amp;skin=vector&amp;*"></script>
<script>if ( window.mediaWiki ) {
	mediaWiki.config.set({"wgCanonicalNamespace": "", "wgCanonicalSpecialPageName": false, "wgNamespaceNumber": 0, "wgPageName": "Spring_Security_framework", "wgTitle": "Spring Security framework", "wgAction": "view", "wgArticleId": 10332, "wgIsArticle": true, "wgUserName": null, "wgUserGroups": ["*"], "wgCurRevisionId": 43737, "wgCategories": [], "wgBreakFrames": false, "wgRestrictionEdit": [], "wgRestrictionMove": []});
}
</script>
<script>if ( window.mediaWiki ) {
	mediaWiki.loader.load(["mediawiki.util", "mediawiki.legacy.wikibits", "mediawiki.legacy.ajax"]);
	mediaWiki.loader.go();
}
</script>

<script>if ( window.mediaWiki ) {
	mediaWiki.user.options.set({"ccmeonemails":0,"cols":80,"contextchars":50,"contextlines":5,"date":"default","diffonly":0,"disablemail":0,"disablesuggest":0,"editfont":"default","editondblclick":0,"editsection":1,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":0,"extendwatchlist":0,"externaldiff":0,"externaleditor":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"highlightbroken":1,"imagesize":2,"justify":0,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nocache":0,"noconvertlink":0,"norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"quickbar":1,"rcdays":7,"rclimit":50,"rememberpassword":0,"rows":25,"searchlimit":20,"showhiddencats":0,"showjumplinks":1,"shownumberswatching":1,"showtoc":1,"showtoolbar":1,"skin":"vector","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":0,"watchdefault":0,"watchdeletion":0,
	"watchlistdays":3,"watchlisthideanons":0,"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,"variant":"hr","language":"hr","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false});;mediaWiki.loader.state({"user.options":"ready"});
}
</script>		<!-- fixalpha -->
		<script type="text/javascript"> if ( window.isMSIE55 ) fixalpha(); </script>
		<!-- /fixalpha -->
		<!-- Served in 0.620 secs. -->			</body>
</html>
